# acwing算法基础课

[toc]
[浅谈子串和子序列的相同点和不同点_子串 子序列-CSDN博客](https://blog.csdn.net/qq_39463175/article/details/124393481)

# 竞赛的基本环境

>  `c++`环境为例

时间限制：1s对应的操作次数需要控制在$10^7\sim 10^8$

> [由数据范围反推算法复杂度以及算法内容 - AcWing](https://www.acwing.com/file_system/file/content/whole/index/content/3074/)

空间限制：$64MB$ = $64 * 1024 KB$=$64 * 1024 *1024 B$，一个整型对应$4B$

也就是说$64MB$最多能开$1.67e7$个整型数组





# 基础算法

## 快速排序

这里我跳过，代码有点难记，一般直接用函数

> 以某个数为标兵，不断将代码分为左右两部分进行排序

> 每次一定会移动一格，注意不要取等

```c++
#include <iostream>
using namespace std;
const int N = 100010;
int q[N];
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];//以x为标兵，分成两部分
        //[l,j]为左界，小于等于x；[j+1,r]为右界，大于等于x
            //为什么这里不以i,j分别为界呢？因为i可能等于j,会有交集
    while (i < j)
    {
        do i ++ ; while (q[i] < x);//左找大于等于
        do j -- ; while (q[j] > x);//右找小于等于
            //这里不跳过等于的，[3,2]如果排序这个，以3为基准跳过了就错了
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j);//注意看这个边界，重点看下面的图
    quick_sort(q, j + 1, r);
}

int main()
{
    int n;
    scanf("%d", &n);
    for (int i = 0; i < n; i ++ ) scanf("%d", &q[i]);
    quick_sort(q, 0, n - 1);
    for (int i = 0; i < n; i ++ ) printf("%d ", q[i]);
    return 0;
}
作者：yxc
```
> 注意喽：**那个分治的边界不是随随便便得**

![IMG20231122115622.jpg](https://cdn.acwing.com/media/article/image/2023/11/22/246003_4c155fe688-IMG20231122115622.jpg)

> 最终其中一种左右区间的分法：$[l,j]$和$[j+1,r]$

### 第k个数

```c++
//nth_element  但需要注意这个函数写的顺序比较特殊

//我记性很差，快排模板容易记错，所以我基本不会用
//快排：就是以一个数为标兵，去不断分为两个区间
/*虽然是分为两个区间，一个小于等于，一个大于等于，
    但是其中没有一个数是能确定位置的，只有只剩一个数的时候能确定*/
#include<bits/stdc++.h>
using namespace std;
//采用以第一个数为标兵
const int maxn=1e5+10;
int a[maxn];
int quick_sort(int l,int r,int k)
{
    if(l>=r)
    {
        return a[k];
    }
    int i=l-1,j=r+1,x=a[(l+r)>>1];//保证第一下一定会动
    while(i<j)
    {
        //左找大于等于
        do i++; while(a[i]<x);
        
        do j--; while(a[j]>x);
        if(i<j)
        {
            swap(a[i],a[j]);    
        }
    }
    if(j>=k)return quick_sort(l,j,k); //j就是那个分界线,万一k==j，你不能用j+1那一部分 
    else    return quick_sort(j+1,r,k);//j+1那一部分
}
int main(){
    int n,k;
    scanf("%d%d",&n,&k);
    for(int i=0;i<n;i++){
        scanf("%d",&a[i]);
    }
    // cout<<quick_sort(0,n-1,k-1);
    
    nth_element(a,a+k-1,a+n);//这个函数书写顺序比较特殊
    //      将编号为k-1的复位
    cout<<a[k-1];
    return 0;
}
```
## 归并排序

```c++
//没完全掌握，现在先掌握思想

//归并排序采用了分治和双指针
//主要思想：将两个有序的数列归并成一个
#include<iostream>
#include<cstdio>
using namespace std;
const int maxn=1e5+10;
int a[maxn];
void merge_sort(int l,int r){
    //直到最后找到区间只剩一个数时返回
    if(l==r){//不能在分割了，只剩下一个了
        return;
    }
    //1.先分为两子区间并变得有序
    int mid= l+r >>1;
    //除2，会向下取整，另一部分要对mid+1(类似二分)
    //否则在最后剩两个是l!=r，很麻烦
    merge_sort(l,mid),merge_sort(mid+1,r);
    
    //2.将当前合并两个有序区间
    int i=l,j=mid+1,k=0;
    int tmp[maxn];//辅助数组
    /*
    双指针主要用在这:
    i指向左区间，j指向右区间，k指向辅助区间（用来暂放合并后的有序数组）
    */
        //(1)将小的数先放入，直到有一个区间结束
    while(i<=mid&&j<=r){
        //这里其实等号取哪都没差，但是为了保证稳定性才这样的（没什么用）
        if(a[j]<a[i]){//小的先放入
            tmp[k++]=a[j++];
        }else{
            tmp[k++]=a[i++];
        }
    }
        //(2)把剩下区间的数放入
    while(j<=r){
        tmp[k++]=a[j++];
    }
    while(i<=mid){
        tmp[k++]=a[i++];
    }
    
    //3.把辅助数组的数（有序且合并后）赋到原数组中
    for(k=0,i=l;i<=r;i++,k++){
        a[i]=tmp[k];
    }
}
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        scanf("%d",&a[i]);
    }
    merge_sort(0,n-1);
    for(int i=0;i<n;i++){
        printf("%d ",a[i]);
    }
    return 0;
}
```


### 求逆序对

逆序对的定义如下：对于数列的第 $i$ 个和第 $j$ 个元素，如果满足 $i < j$ 且 $a[i] > a[j]$，则其为一个逆序对；否则不是。

> 使用冒泡排序(每次交换**相邻**的两个数)，最小交换次数就是逆序对的个数
>
> 分析：
>
> > 排完序后就是没有逆序对了
> >
> > 相邻的交换，只会影响一对逆序对(加或减1)，不会影响其他的，就是说交换次数必然大于等于逆序对数k
> >
> > 能不能等于呢？
> >
> > 如果不是升序的话，每次必然会存在相邻的逆序对，那么就交换那个就行了





>  （如果数不大的话，用树状数组思路更简单，数大还需要离散化）



---

 **每次左右两区间合并统计产生的逆序对个数** 

**注意：**

1. **当数放入时，才统计该数对应的逆序对**

2. 其实选左右的区间的两个都行，但是为了避免一些特判情况，最好选**a[i/j]能对应到那些还没放入的部分** 
    (就是统计最好要能统计那些还没有放入)
    
3. 注意等号的情况（逆序对不包含等号）

    > 求逆序对时，是当右区间放入时，统计那些左区间中还没有放入的（剩下的都比右边大）
    >
    > 当$a[i]==a[j]$时，应当放入到左区间中，这时剩下那些就没有等于的了



```c++
/*
归并排序：  
    主要思想：将两个有序的数列归并成一个

根据性质：
    i<j,只需找a[i]>a[j]

当两区间归并，i<j一定满足，因为这两区间是有序的，
很好统计左右两区间的逆序对
恰为：mid-i+1（包扣i这个数）
    注意这里只统计放归并过程中放右区间的时候
    右区间的序号一定比左区间大，
    如果右区间早放入的话，与左区间后面所有数的就是逆序对

在开始合并前：
    左右区间的逆序数已经被统计好了
每次合并只是计算一下合并产生新的逆序数
*/
//需要算一下是否需要long long
#include<bits/stdc++.h>
using namespace std;
int n;
const int N=1e5+10;
int a[N];
typedef long long ll;
ll cnt;
void merge_sort(int l,int r){
    if(l>=r){
        return;
    }
    int mid=(l+r)>>1;
    //变得有序
    merge_sort(l,mid),merge_sort(mid+1,r);
    //归并过程
    int i=l,j=mid+1;
    int tmp[N],k=0;
    //小的放前
    while(i<=mid&&j<=r){
        if(a[j]<a[i]){
            //逆序对情况
            tmp[k++]=a[j++];
            cnt+=mid-i+1;//统计两区间合并新产生的逆序数
        }else{
            tmp[k++]=a[i++];//相等的情况会被放入，统计不到
        }
    }
    //扫尾
    while(i<=mid){
        tmp[k++]=a[i++];
    }
    while(j<=r){
        tmp[k++]=a[j++];
    }
    //赋回
    for(i=l,k=0;i<=r;i++,k++){
        a[i]=tmp[k];
    }
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    merge_sort(0,n-1);
    cout<<cnt;
    return 0;
}
```
 注意：ll类型最好用cout输出，如果用c语言输出用 **%lld**
 （跟java区分，java中%d能输出所有的十进制类型）

```c++
解释一下：注意事项的第2点
为什么这里选择a[j]放入时统计呢？
1. 
（其实在a[i]放入也能统计出来，
  当a[i]没放完时，在扫尾时还需要统计【当前a[i]在前面的右区间个数】
  （最好在扫尾前统计））
  

2.  
如果选择了a[j]放入时统计
    跟前面一样，a[j]在扫尾前就放完，则已经统计完了
    当a[j]还需要扫尾，则说明i=mid+1,此时不会增加
        （换种理解方式，就是a[j]放合并的末尾，不会产生逆序对）

```
## 二分

[二分查找 & 二分答案 万字详解](https://blog.csdn.net/Mr_dimple/article/details/114656142/)

![二分1.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_df63035052-二分1.jpg)

助记说明一下吧：

二分的l,r肯定是有靠近趋势的，下面说的【配等】就是最后结果要让`l=r`

- 首先你需要明确是找符合的最小（**左**）还是最大值(**右**)，判断是向左（`l+r >>1`下取整，配等时要+1）还是向右模板（`l+r+1 >>1`上取整，配等时-1）【**注意喽：看求什么最值判断是什么取整**】

- 二分你就理解为用目标（那个k）划分为两个区间（那个图肯定是要画的）

  先以找符合条件的最小值为例：（向左）

  1. 用目标划分成两个区间，符合条件的最小值肯定是在右区间的最左边，所以这个右区间要取等：

     因此"左区间中的值<条件"；"右区间>=条件"

  2. 直接这么记：答案在哪边，"哪边=mid"，然后另一边配等就行（看是+1还是-1）（左找：答案在右区间，因此`r=mid,l=mid+1`）

     (如果上面忘记，还能这么记：就是在那个**图中**模拟下配等过程，`l`写在区间分界点左边，`r`写在分界点的右边，因为答案为`r`，`mid`这时等于l，所以这时`l=mid+1,r=mid`  {`l`需要跨越边界})

  找最大值也是同样的分析过程

- (二分答案时，如果刚好答案要求要正好取到某个数时)**当二分的结果无法取等时**，看看要做啥特殊操作

  

  - **边界问题**
  
    - 如果只是单纯的找一个数：你最后判一下是否等于目标就能解决了
    
    - **如果是求某个区间**（像求什么符合条件的个数）：（不忽略可以少一些特判情况），这时尽量不要忽略：
    
      主要就是怕整个数组中都没有出现目标区间，并且你还期望它在答案所在的区间。
    
      
    
      如果还是以左找为例的话：
    
      ​        如果数组都在左区间，但是我们想让它最终停在右区间（如果答案存在会在右区间），那么这时，你可以在数组后面加个不存在的点=>`l=0,r=n`，如果实际数组中不存在右区间，这时最终会停在n，相当还是在右区间
      
      >  举个会出现边界问题的例子:
      >
      >  比如：1 2 3 4 5  找$2<=k<=6$，找符合条件的个数（答案：2，3，4，5；一共4个）
      >
      >  如果忽略掉边界`l=0,r=n-1`，然后都用左找模型
      >
      >  ```c++
      >  如果按stl相同的划分法：答案=【大于y的第一个下标】-【不大于x的第一个下标】
      >                      第一次二分:
      >                          找大于等于x的最小值（左找模板）
      >                          左区间：<x；右区间：>=x
      >                      第二次二分：（注意这里）
      >                          找大于y的最小值（左找模板）
      >                          左区间：<=y；右区间>y   
      >            左找模板，如果没有右区间就会出问题，最终他会停留到左区间最右侧，就是`<=y`的位置，这时就不是想找的【大于y的第一个下标】了
      >        
      >            最终`l=1,r=4`显然不是正确答案
      >            如果不忽略，最终就是`l=1,r=5`
      >  ```
      >



- **注意：二分答案时，==一定要考虑当前点答案不存在的情况==**，看需要做啥特判处理


![二分2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_e55b098752-二分2.jpg) 

二分答案本质是一种逆向思维：（想不出来的时候：试一下从答案推回去是否可行）

(如果是符合条件的最小最大值都能试试)

- **情景**：如果**从答案逆向推回去比较简单，并且有明显的分界线**【二段性】（比如：小于k时符合条件，大于等于k就不符合了），这时候一定要试试
- **答案范围**：注意边界问题后，你可以范围大，但是**一定不能小了**











**AcWing789. 数的范围**

给定一个按照升序排列的长度为 $n$的整数数组，以及$q$个查询。

对于每个查询，返回一个元素$k$的起始位置和终止位置（位置从$ 0 $开始计数）。

如果数组中不存在该元素，则返回 ``-1 -1``。

------



 **stl** 

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
#define endl '\n'
int main(){
    int n,q;
    cin>>n>>q;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    while(q--){
        int x;
        cin>>x;
        int l=lower_bound(a,a+n,x)-a;
        //找出现的第一个位置；若没有找到，找大于的第一个数
        int r=upper_bound(a,a+n,x)-a;
        //找大于的第一数
        if(l==r){
            cout<<"-1 -1"<<endl;
        }else{
            cout<<l<<" "<<r-1<<endl;
        }
    }
    
    return 0;
}
```
 **二分模板**
```c++
/*
写二分的时候推荐按区间画一下图：
    （方便判断边界和取等问题）
    按两个判断区间分，要找的东西都在中间，
    左区间找右边（向右模板），右区间找找左边
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
#define endl '\n'
int main(){
    int n,q;
    cin>>n>>q;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    while(q--){
        int x;
        cin>>x;
        //左右模板都是要用的
        
        //先向左
        //这题其实都不用管边界问题
        int l=0,r=n-1;
        while(l<r){
            int mid=(l+r)>>1;//向下取整对应向左
            if(a[mid]>=x){
                r=mid;//区间向左缩
            }else{
                l=mid+1;//保证能重合且最好是在自己画的图的右区
            }
        }
        if(a[l]!=x){
            cout<<"-1 -1"<<endl;
        }else{
            cout<<l<<" ";
            r=n-1;
            //向右模板
            while(l<r){
                int mid=(l+r+1)>>1;//向上取整
                if(a[mid]<=x){
                    l=mid;
                }else{
                    r=mid-1;//保证重合
                }
            }
            cout<<r<<endl;
        }
    }
    
    return 0;
}
```
## 浮点二分
**数的三次方根**
```c++
//开始的时候没搞懂，这个是类似二分答案
//由于是浮点二分，需要将误差控制在一定区间

//可用cbrt函数
#include<bits/stdc++.h>
using namespace std;
double n;
bool check(double mid){
    double a=mid*mid*mid;
    if(a<=n){//向左
        return 0;
    }else{//向右
        return 1;
    }
}
int main(){
    
    scanf("%lf",&n);
    // if(n>0){
    //     printf("%.6f",pow(n,1.0/3));
    //     return 0;
    // }
    //好吧，pow不行，遇到负数时会出现复数解,返回nan
    //负数是特殊情况，需要特判
    double l=-1e4,r=1e4;
    while(r-l>1e-8){
        //浮点二分
        double mid=(l+r)/2;
        if(check(mid)){
            r=mid;
        }else{
            l=mid;
        }
    }
    printf("%0.6f",l);
    cout<<endl<<;
    return 0;
}
```

##  高精加和高精乘 
 **结构体封装** 
```c++
//这些都要特别注意一下0

//一开始在洛谷上学的，我就不改了
#include<bits/stdc++.h>
using namespace std;
struct bigint{
    int a[200020];
    int len=0;
    /*
    bigint(int a){
        while(a){
            a[len++]=a%10;
            a/=10;
        }
        len--;
    }
    */
    bigint(string s){
        //注意最高为在前
        len=s.size()-1;
        for(int i=len,j=0;i>=0;i--,j++){
            a[i]=s[j]-'0';
        }
    }
    bigint(){}
    int &operator[](const int i){
        //简写，用bigint b;b.a[i]等价于b[i]
        //但一定要注意&
        return a[i];
    }
    void flat(int l){
        len=l;
        for(int i=0;i<=l;i++){
            a[i+1]+=a[i]/10;
            //注意是加等于，别跟犯一个错误，呜呜呜
            a[i]%=10;
        }
        while(a[len]==0&&len){
            len--;
        }
    }
    void print(){
        for(int i=len;i>=0;i--){
            cout<<a[i];
        }
    }
};
//高精加
bigint operator+(bigint a,bigint b){
    bigint c;
    int l=max(a.len,b.len)+2;
    for(int i=0;i<=l;i++){
        c[i]=a[i]+b[i];
    }
    c.flat(l);
    return c;

}

//高精乘(大整形*大整型)
bigint operator*(bigint a,bigint b){
    bigint c;
    int l=a.len+b.len+3;
    for(int i=0;i<=a.len;i++){
        for(int j=0;j<=b.len;j++){
            c[i+j]+=a[i]*b[j];
        }
    }
    c.flat(l);
    return c;
}
//高精乘（大整形*普通）
bigint operator*(bigint a,int b){
    bigint c;
    int l=a.len+10;
    for(int i=0;i<=a.len;i++){
        c[i]+=a[i]*b;
    }
    c.flat(l);
    return c;
}
```
```c++
高精加
int main(){
    string a,b;
    cin>>a>>b;
    bigint A(a),B(b);
    bigint c=A+B;
    c.print();
    return 0;
}
```
```c++
高精乘
int main(){
    string x;
    int b;
    cin>>x>>b;
    bigint a(x);
    bigint c;
    c=a*b;
    c.print();
    return 0;
}
```



**vector版**


```c++
#include<iostream>
#include<vector>
#include<bits/stdc++.h>
using namespace std;
void chushi(vector<int> &a,string &s){
    //需要个位放第一位最好
    //若从末尾开始存，很难加数
    for(int i=s.size()-1;i>=0;i--){
        a.push_back(s[i]-'0');
    }
}
vector<int> operator+(vector<int> &a,vector<int> &b){
    int t=0;//这个需要注意，用来记录进位
    vector<int> c;
    for(int i=0;i<a.size()||i<b.size();i++){
        if(i<a.size()){
            t+=a[i];
        }
        if(i<b.size()){
            t+=b[i];
        }
        c.push_back(t%10);
        t/=10;
    }
    if(t){
        c.push_back(t);
    }
    return c;
}
int main(){
    
    string a,b;
    cin>>a>>b;
    vector<int> A,B;
    chushi(A,a);
    chushi(B,b);
    vector<int> C;
    C=A+B;
    for(int i=C.size()-1;i>=0;i--){
        cout<<C[i];
    }
    return 0;
}
```
## 高精减
```c++
//两整数相减
//为了方便计算，都转化为绝对值相减，符号进行特判
#include<iostream>
#include<vector>
using namespace std;
//判断正负，并保证是大数减小数(一定为正，后面在填符号)
bool cmp(string a,string b){
    int la=a.size(),lb=b.size();
    if(la!=lb){
        return la>lb;
    }else{
        return a>=b;//注意这里要有等号，相等时不为负数
    }
}
void init(vector<int> &a,string &s){
    //注意：最高位是个位
    for(int i=s.size()-1;i>=0;i--){
        a.push_back(s[i]-'0');
    }
}
vector<int> operator-(vector<int> &a,vector<int> &b){
    vector<int> c;
    int t=0;//处理借位和减法
    for(int i=0;i<a.size()||i<b.size();i++){
        if(i<a.size()){
            t+=a[i];
        }
        if(i<b.size()){
            t-=b[i];
        }
        c.push_back((t+10)%10);
        if(t<0){
            t=-1;//借位
        }else{
            t=0;
        }
    }
    while(c.back()==0&&c.size()!=1){
        c.pop_back();
    }
    return c;
}
int main(){
    string a,b;
    cin>>a>>b;
    //为了方便计算，保证a>b
    bool fu=0;//符号的判定
    if(!cmp(a,b)){
        swap(a,b);
        fu=1;
    }
    vector<int> A,B;
    //初始化
    init(A,a);
    init(B,b);
    
    vector<int> C=A-B;
    if(fu){
        cout<<"-";
    }
    for(int i=C.size()-1;i>=0;i--){
        cout<<C[i];
    }
    return 0;
}
```
## 高精乘
**vector版**
```c++
//可能出现0*n,还是需要除前导0

#include<bits/stdc++.h>
using namespace std;
#define VI vector<int> //简写
VI operator*(VI &a,int b){
    VI c;
    int t=0;//处理乘法和进位
    for(int i=0;i<a.size();i++){
        t+=a[i]*b;
        c.push_back(t%10);
        t/=10;
    }
    while(t){
        //也可写在for那边
        c.push_back(t%10);
        t/=10;
    }
    while(c.back()==0&&c.size()!=1){
        c.pop_back();
    }
    return c;
}
int main(){
    string a;
    int B;
    cin>>a>>B;
    //初始化
    VI A;
    for(int i=a.size()-1;i>=0;i--){
        A.push_back(a[i]-'0');
    }
    auto C=A*B;//自动判断类型
    for(int i=C.size()-1;i>=0;i--){
        cout<<C[i];
    }
    return 0;
}
```
## 高精除
```c++
/*
模拟一下除法，
会发现除法是从最高位开始，从最高位开始存确实会方便一点
但为了保证加减乘除的一致性，还是从最低位开始存

还需要除前导0
*/
#include<iostream>
#include<algorithm>
#include<vector>
using namespace std;
#define VI vector<int>

//高精除
int r;//用来存余数
VI operator/(VI &a,int b){
    VI c;
    for(int i=a.size()-1;i>=0;i--){
        //会发现高位在前
        r=r*10+a[i];
        c.push_back(r/b);
        r%=b;
    }
    //翻转(保证从个位开始存，同时方便除0)
    reverse(c.begin(),c.end());
    while(c.back()==0&&c.size()>1){
        c.pop_back();
    }
    return c;
}
int main(){
    string a;
    int B;
    cin>>a>>B;
    //初始化
    VI A;
    for(int i=a.size()-1;i>=0;i--){
        A.push_back(a[i]-'0');
    }
    VI C=A/B;
    //输出
    for(int i=C.size()-1;i>=0;i--){
        cout<<C[i];
    }
    cout<<endl<<r;
    return 0;
}
```
[前缀和与差分 图文并茂 超详细整理（全网最通俗易懂）_前缀和差分-CSDN博客](https://blog.csdn.net/weixin_45629285/article/details/111146240)

## 前缀和



![前缀和.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_86a4137652-前缀和.jpg) 
 **像这种最好都画画图** 

**一维**
```c++
//呜呜，一定要有判断是否需要开高精度的思想

#include<bits/stdc++.h>
using namespace std;
const int N=1e5;
int sum[N];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        //这种一般都是从1开始记录
        cin>>sum[i];
        sum[i]+=sum[i-1];
    }
    while(m--){
        int l,r;
        cin>>l>>r;
        cout<<sum[r]-sum[l-1]<<endl;
    }
    
    return 0;
}
```
 **二维**
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1010;
//不会爆int
int s[N][N];

int main(){
    int n,m,q;
    cin>>n>>m>>q;
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>s[i][j];
            s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];
        }
    }
    while(q--){
        int x1,x2,y1,y2;
        cin>>x1>>y1>>x2>>y2;
        cout<<s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1]<<endl;
    }
    return 0;
}
```
## 差分
![差分1.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_60b9957452-差分1.jpg) 
![差分2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_65853b6952-差分2.jpg) 
**一维** 
数轴上给某段区间都加上某个数

```c++
//当然，y总那种更具有普遍性，有利于理解二维的
//差分数组在某个位置上加，相当于后面每个数都加
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
//可能会越界
typedef long long ll;
ll b[N];
int a[N];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        b[i]=a[i]-a[i-1];//注意一下
    }
    
    while(m--){
        int l,r,c;
        cin>>l>>r>>c;
        b[l]+=c;
        b[r+1]-=c;
    }
    
    for(int i=1;i<=n;i++){
        b[i]+=b[i-1];
        cout<<b[i]<<" ";
    }
    return 0;
}
```

### 通过区间操作，将数组变为目标数组

> 每次能将区间加减1，目标是将整个数组都变为0
>
> 结论：**对于差分数组[1,n+1]，就是其中的正数和**

[4262. 空调 - AcWing题库](https://www.acwing.com/problem/content/description/4265/)

题目：给定两个数组长度$n$，$T$数组要变为目标数组$P$数组。 

​			就是将原序列的连续一段全部增加或者减少$1$，求出变成目标序列的最小操作数

---

时间复杂度：仅需$O(n)$

> 下面的是y总的思路

思路：

> 【$T$->$P$】  等价于 【$D=P-T$->$0$】  等价于  【将$D$数组的差分数组$B$-> $0$的差分数组（都是0）】
>
> > 变换的顺序是对这题是无所谓的
>
> > 为什么最后要转为差分数组呢？
> >
> > - 差分数组本质就是**原数组的另一个角度。**
> > - 转为差分操作，**能将区间操作变为单点操作**
>
> 问题变为：通过两个单点修改让差分数组$B$都变为0
>
> 每次的差分操作：
>
> > 对区间$[l,r]$加减1，等价于对差分数组中的$l$加减1，$r+1$减加1
>
> - 每次只能任选一个正数+1和任选一个负数-1
>
>   > 至于这个区间是加是减无所谓，对称的，换下顺序就行了
>
>   > 这里把$n+1$也算上的话：(因为单点操作需要$r+1$)
>   >
>   > > 那么差分数组$[1,n+1]$的和就是[n+1]这个位置上的数=0
>   > >
>   > > 也就是说负数会等于正数
>
> - 也就是说每次挑正数时，必然对应一个负数进行操作
>
> **$res=差分数组的正数之和$**



> (上面的那种会更加简单一点)
>
> 这里如果范围为$[1,n]$
>
> 对应的差分操作：
>
> - 每次只能任选一个正数+1和任选一个负数-1，当不够时就放在$n+1$那边
>
> **$res=max(差分数组的正数之和，负数之和)$**

```java
import java.util.*;
import java.io.*;
public class Main{
	//具体分析过成看上面
	static int N=(int)1e5+10;
	static int n;
	static int[] b=new int[N];	//最终表示差分数组，一个数组就能搞定了
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		n=Integer.parseInt(br.readLine());
		String[] ss=br.readLine().split(" ");
		for(int i=1;i<=n;++i)
			b[i]=Integer.parseInt(ss[i-1]);//当前b表示P数组
		ss=br.readLine().split(" ");
		for(int i=1;i<=n;++i)
			b[i]-=Integer.parseInt(ss[i-1]);//当前表示P数组-T数组
			//转为差分后，每次只能同时对一个数+1和另一个数-1，那么需要操作的次数>=max{正数和，负数和}
		
		//注意喽：范围[1,n+1]，只需要求差分数组正数之和
		//转为P-T的差分数组，将区间操作变为单点修改操作
			//这里类似滚动优化那一边的
		for(int i=n+1;i>=1;--i)//注意顺序
			b[i]-=b[i-1];//b[i]=D[i]-D[i-1];也就是说要保证b[i-1]还是D[i-1]
		int res=0;
		for(int i=1;i<=n+1;++i) 
			if(b[i]>0) res+=b[i];
		System.out.println(res);
	}
}
```

参考：
[AcWing 4262. 空调 - AcWing](https://www.acwing.com/solution/content/65561/)
y总的两个视频

----------




 **二维**
输入一个 $n$ 行 $m$ 列的整数矩阵，再输入 $q$ 个操作，每个操作包含五个整数 $x_1, y_1, x_2, y_2, c$，其中 $(x_1, y_1)$ 和 $(x_2, y_2)$ 表示一个子矩阵的左上角坐标和右下角坐标。
每个操作都要将选中的子矩阵中的每个元素的值加上 $c$。

```c++
 /*先将数组想象为空，
   插入（加）一个数就是将后面所有的数都加上这个数
   也就是说，后面你需要消除这种变化*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e3+10;
int b[N][N];

//插入操作，想想可以添加数等价
void insert(int x1,int y1,int x2,int y2,int c){
    b[x1][y1]+=c;
    b[x2+1][y1]-=c;
    b[x1][y2+1]-=c;
    b[x2+1][y2+1]+=c;
}
int main(){
    int n,m,q;
    cin>>n>>m>>q;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            int c;
            cin>>c;
            insert(i,j,i,j,c);
        }
    }
    while(q--){
        int x1,y1,x2,y2,c;
        cin>>x1>>y1>>x2>>y2>>c;
        insert(x1,y1,x2,y2,c);
    }
    
    //求前缀和，就是原值
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            b[i][j]+=b[i-1][j]+b[i][j-1]-b[i-1][j-1];
            cout<<b[i][j]<<" ";
        }
        cout<<endl;
    }
    return 0;
}
```
## 双指针
==前提条件：  _**移动方向固定，不会往回走**_==

**经验**：就是一个右指针一步步往右走（**尽量就是当作一个右界**），然后左指针根据右指针的情况走

> 主要就是因为这样会好写很多，是一种经验

```c++
for(右指针i=0;i<n;++i){//每次右指针都会走一个【右界】
     while(j<=i&&条件){//左指针【左界】

     }
}
```

### 最长连续不重复子序列

```
给定一个长度为 n 的整数序列，请找出最长的不包含重复的数的连续区间，输出它的长度。
```
```c++
/*
可恶，其实我题意疯狂理解错，
这里的连续不是1，2，3，4，的子序列
而是指在按原来的序列连续的不重复的串(是连在一块的)
例：
1 2 {2 3 5}

9 {3 6 9 5 10 1 2} 3 9
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N],cnt[N];//a用来记录原数组，cnt用来记录[j,i]个数的出现个数
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++) cin>>a[i];
    
    int ans=1;
    for(int i=0,j=0;i<n;i++){
        //这里的i是右指针，j表示左指针
        cnt[a[i]]++;
        while(cnt[a[i]]>1){//判断是否重复
            //这里其实有个隐含条件：i>=j
            //因为区间只有一个数时，此时（i==j）一定满足不重复
            
            cnt[a[j]]--;//呜呜，注意一下这里(顺序和j)别写错了
            j++;
            
        }
        ans=max(ans,i-j+1);
    }
    cout<<ans<<endl;
    return 0;
}
```
### 数组元素的目标和

题：
给定两个升序排序的有序数组 $A$ 和 $B$，以及一个目标值 $x$。
数组下标从 $0$ 开始。
请你求出满足 $A[i]+B[j]=x$ 的数对 $(i,j)$。
数据保证有唯一解。

---

```c++
/*  经过模拟发现
    指针i指向第一个序列的左（往右）
    指针j指向第二个序列的右（往左）*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N],b[N];
int main(){
    int n,m,x;
    cin>>n>>m>>x;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=0;i<m;i++){
        cin>>b[i];
    }
    
    int i=0,j=m-1;
    for(;i<n;i++){
        while(a[i]+b[j]>x&&j>=0){
            j--;
        }
        if(a[i]+b[j]==x){
            break;
        }
    }
    cout<<i<<" "<<j;
    return 0;
}
```
###  判断子序列 :

给定一个长度为 $n$ 的整数序列 $a_1,a_2,…,a_n$ 以及一个长度为 $m$ 的整数序列 $b_1,b_2,…,b_m$。

请你判断 $a$ 序列是否为 $b$ 序列的子序列。

> **子序列**:指序列的一部分项按**原有次序排列**而得的序列
>
> > 例如序列$\{a_1,a_3,a_5\}$ 是序列 $\{a_1,a_2,a_3,a_4,a_5\}$ 的一个子序列。
>
> **整个概念好好看看**

```c++
//呜，又想二分了
//两个数组的双指针，都指向对头（往右）

#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N],b[N];
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    for(int i=0;i<m;i++){
        cin>>b[i];
    }
    
    int i=0,j=0;
    for(;i<n;i++){
        while(a[i]!=b[j]&&j<m){
            j++;
        }
        //怕错，就不优化了
        if(j>=m){
            break;
        }
        j++;//忽略了，找到了还是需要往前走的
    }
    if(i==n){
        cout<<"Yes";
    }else{
        cout<<"No";
    }
    return 0;
}
```
### 尽量将双指针写成这种形式

[3745. 牛的学术圈 I - AcWing题库](https://www.acwing.com/problem/content/description/3748/)

> ==**逆向思维：从答案倒推回去是否符合**==

原题描述的太抽象了，需要变换一下，会好懂一点

1. h指数表示【至少有h个数>=h】
2. 每个数最多能补$1$，并且最多补$1$次

求出$h$的最大值

**数据范围**：$1 \le N \le 10^5$,$0 \le c_i \le 10^5$, $0 \le L \le 10^5$


----

> 一开始想直接求，但是失败了
>
> 本题本身就有点抽象，属于双指针中比较难的题

#### 二分答案版

> 会直观很多

```java
//本题自己尝试写，失败了，原本的思路不知道为什么会超时，双指针会有很多细节问题
	//多画画图，会更形象点

/*本题像题目描述的太抽象的
 * 	1. 最好转化为h表示【>=h的数至少有h个】
 * 	2. 然后每个数最多只能补1
 */
/**
 * 二分答案：（一开始最好就要尝试一下）
 * (会直接特别多)
 * 		如果已知答案逆向判断会比较简单，并且有二段性，就可以尝试
 * 		
 * 		正确答案为h：
 * 			这个边界会出出现在cnt[h]=h或者cnt[h]=h-1附近
 * 			再前面都是大于下标；后面的数只能+1也补不上
 * 		所以具有二段性，能够二分，前面都是可行的，后面都是不行的
 */
import java.util.*;
import java.io.*;
public class Main{
	static int N=(int)1e5+10;
	static int n,l;
	static Integer[] c=new Integer[N];
	
	/**
	 * 判断是否至少有h个数>=h
	 * 对于刚好等于h-1的数最多能补l次
	 * @param h
	 * @return 可以时返回true
	 */
	static boolean check(int h) {
		int a=0,b=0;
			//a记录大于等于h，完成不用补的
			//b记录等于h-1，能补的
		//二分后甚至都不用排序了
		for(int i=1;i<=n;++i) {
			if(c[i]>=h) 	   ++a;
			else if(c[i]==h-1) ++b;
		}
		return a+Math.min(l,b)>=h;
					//最多也就只能补l个
		
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		String[] ss=br.readLine().split(" ");
		n=Integer.parseInt(ss[0]);
		l=Integer.parseInt(ss[1]);
		ss=br.readLine().split(" ");
		for(int i=1;i<=n;++i) 
			c[i]=Integer.parseInt(ss[i-1]);
		//二分答案，枚举h
		int l=0,r=n;
			//找的是符合答案的最大值
		while(l<r) {
			int mid=l+r+1 >>1;
			if(check(mid)) l=mid;
			else		   r=mid-1;
		}
		System.out.println(l);
	}
}
```

#### 双指针版

> 这个挺抽象，最好就是配合图来理解

![双指针：牛的学术圈Ⅰ.jpg](https://cdn.acwing.com/media/article/image/2024/04/02/246003_cc31e594f0-双指针：牛的学术圈Ⅰ.jpg) 

```java
//双指针直接尝试的正向写法失败了
//h：需要满足至少有h个数>=h；每个数最多能补1，最多补l次
/**
 * 双指针做法：
 * 		（这里写的是y总的那种，确实有点难懂）
 * 		这里其实是有点逆向思维的，也是根据h具有明显的二段性
 * 	思路：
 * 		判断i这个数是否为h？（从大到小枚举，能保证h是最大值）
 * 		1.C[h]>=h不用管，本来就不需要补
 * 		2.C[h]=h-1，则需要看这部分到底有多长，是否小于h
 * 		3.其他的已经补不了了，不用管了
 * 		也就是说这里双指针：
 * 			只要找到>=h的第一个数，由于逆序排了，
 * 			随着h的增大，C数组指向的下标只会往前走
 * 			所以能用双指针
 */
import java.util.*;
import java.io.*;
public class Main{
	static int N=(int)1e5+10;
	static int n,l;
	static Integer[] c=new Integer[N];
	
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		String[] ss=br.readLine().split(" ");
		n=Integer.parseInt(ss[0]);
		l=Integer.parseInt(ss[1]);
		ss=br.readLine().split(" ");
		for(int i=1;i<=n;++i) 
			c[i]=Integer.parseInt(ss[i-1]);
		Arrays.sort(c,1,n+1,(a,b)->{
			return b-a;//逆序排
		});
		int res=0;
		//这里小改一下i实际就是枚举h的最大可能
		for(int h=1,j=n;h<=n;++h) {
			//找到大于等于h的第一个数，如果C[h]刚好为h-1才能补
			while(j>=1&&c[j]<h)
				--j;
			if(c[h]>=h-1&&h-j<=l) //如果在h后头不用管
				res=h;
		}
		System.out.println(res);
	}
}
```

### 统计子矩阵(==二维转一维==：前缀和+双指针)

[AcWing 4405. 统计子矩阵（蓝桥杯辅导课） - AcWing](https://www.acwing.com/activity/content/problem/content/9728/)

给定一个 $N \times M$ 的矩阵 $A$，请你统计有多少个子矩阵 (最小 $1 \times 1$，最大 $N × M$) 满足子矩阵中所有数的和不超过给定的整数 $K$?

**数据范围：**$1 ≤ N, M ≤ 500; 0 ≤ A_{ij} ≤ 1000; 1 ≤ K ≤ 2.5 \times 10^8$

----
> 本题思路还是挺有启发性的，以前都没有想过这个做法
>
> 关键点还是不重不漏的枚举，这里通过枚举其中的一条边的位置，另一条边就能转为一维

> **思路**：(二维转一维)
>
> 枚举左右边的**上下边界范围**：
>
> > 右指针$R$指向右边，一步步向右走
> >
> > > 左指针$L$指向左边，来找包含当前右边的最大矩阵
> > >
> > > > 包含右边的子矩阵个数共有$R-L+1$

**模板写法：** 如果在同一个数组上，最好就是一个右指针（同时就是右边界），另一个左指针一般不会超过右指针

```java
/**
 * 整体思路：将二维化为一维，每次只计算包含这条右边的子矩阵个数
 * 	（这样才能不重不漏的枚举矩阵，当然主要是因为边都是正的，才能用双指针）
 * 
 * 步骤：
 * 	每次只枚举左右边界范围(上下边界)：
 * 		（双指针思想，每次固定就是包含这条右边）
 * 		找左边最靠左的边界L，并使得这个【包含右边】的最大子矩阵子矩阵
 * 		这里面包含右边的子矩阵个数共有R-L+1
 * 这样能够不重不漏的枚举
 * 		
 * ：就是固定一条边，看包含这条边所有矩阵
 * 
 * 双指针最好最好就是留一个一步步往右指针，另一个左指针不会超过右边界
 * 
 * 这里只需要列的前缀和就够了：
 * 		因为这里右边是一步步往右走，所有只要不断加上新的右边就行了
 * 		然后就是左边界也是一步步往左走，不断减去当前左边就行了
 */
import java.util.*;
import java.io.*;
public class Main{
	static final int N=510;
	static int n,m,K;
	static int[][] s=new int[N][N];//列前缀和，这个能够转为一维，把线当成一个点来加
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		String[] ss=br.readLine().split(" ");
		n=Integer.parseInt(ss[0]);
		m=Integer.parseInt(ss[1]);
		K=Integer.parseInt(ss[2]);
		for(int i=1;i<=n;++i) {
			ss=br.readLine().split(" ");
			for(int j=1;j<=m;++j) {
				s[i][j]=Integer.parseInt(ss[j-1]);
				s[i][j]+=s[i-1][j];//只要列的前缀和
			}
		}
			
		long res=0;//算一下一个矩阵的子矩阵个数，会爆int
		for(int i=1;i<=n;++i) 
			for(int j=i;j<=n;++j) 
			//枚举右边的上下边界
				for(int r=1,l=1,sum=0;r<=m;++r) {
				//r就是当前右边的位置
					sum+=s[j][r]-s[i-1][r];//加上当前的右边
					//找当前左边界的最左值
					while(sum>K) {//大了
						sum-=s[j][l]-s[i-1][l];//减去这个左边
						++l;
					}
					res+=r-l+1;
				}
		System.out.println(res);	
	}
}
/**
 * （直接跳过这里讲的是错误的思路）
 * 关键点：不重不漏的枚举所有成立的子矩阵
 * 暴力做法比较好想：
 * 		就是枚举所有的子矩阵判断是否小于k，就行了
 * 
 * 第一次尝试是失败的，思路就是从一个最大矩形出发，直接求其中所有的子矩阵
 * 但是这样最后发现根本没法不重不漏的枚举
 */
```

## 二进制中1的个数

**lowbit**:连负数都能算

```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        int a;
        cin>>a;
        //法1 cout<<__builtin_popcount(a)<<" ";
        /*
        法2：
        int cnt=0;
        while(a){
            if(a&1){
                cnt++;
            }
            a>>=1;
        }
        */
        //法3：（lowbit函数）
        int cnt=0;
        while(a){
            //不断减去最末尾的1
            int lowbit=a&-a;
            a-=lowbit;
            cnt++;
        }
        cout<<cnt<<" ";
    }
    return 0;
}
```
## 离散化

```
题：
    求一个无限长的轴的上，某段区间的和
```
离散化：把原来第k小的元素映射到k

**注意点的总数**

![离散化1.jpg](https://cdn.acwing.com/media/article/image/2023/08/16/246003_6fff98f73c-离散化1.jpg) 
![离散化2.jpg](https://cdn.acwing.com/media/article/image/2023/08/16/246003_741f540b3c-离散化2.jpg) 

```c++
/*
离散化：（我感觉更像是连续化doge）
    将原来稀疏的区间化为连续区间

本题是一段无限长的x轴，其中分布的点很分散，
这时候就可以将所有的点打包成一段区间，并将其中的缝隙去掉，
变成一个新的轴（从1开始，方便便后面的前缀和等操作），点是连续分布的

注意：我们离散的对象是x轴，变成一个新的轴（后面称为a轴了）

例：（将原来的(用到的)绝对坐标转化为了顺序坐标）
    点只分布x=-100,x=-20,x=10,x=60
    离散后a=1(映射x=-100),a=2(x=-20),a=3(10),a=4(60)
    
关键点：1.排序2.去重3.找原坐标所对应的离散化的点
*/
#include<bits/stdc++.h>
using namespace std;

const int N=3e5+10;//添加操作和查询操作一共的x坐标数量

int arr[N],sum[N];
typedef pair<int,int> pii;
vector<int> alls;//a轴，离散化后的结果，存的是映射到的x坐标
vector<pii> add,query;//添加操作和询问操作

int find(int x){//找原坐标对应的离散后坐标

    //映射的x坐标是有序的，因此可以用二分
    //这里用左用右应该都行
    int l=0,r=alls.size()-1;
    while(l<r){
        int mid=(l+r)>>1;
        if(x<=alls[mid]){
            r=mid;
        }else{
            l=mid+1;
        }
    }
    
    return l+1;
    //这里要加1，因为vector默认从0开始存
    //加1后是为了方便前缀和的运算
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=0;i<n;i++){
        int x,c;
        cin>>x>>c;
        add.push_back({x,c});
        alls.push_back(x);
    }
    for(int i=0;i<m;i++){
        int l,r;
        cin>>l>>r;
        query.push_back({l,r});
        alls.push_back(l);
        alls.push_back(r);
    }
    
    //排序
    sort(alls.begin(),alls.end());
    //去重
    alls.erase( unique(alls.begin(),alls.end()) , alls.end());
    
    //在离散后的坐标中插入值
    for(auto t:add){
        //t表示遍历add中所有的值，相当于alls[i]
        int a=find(t.first);
        arr[a]+=t.second;
    }
    
    //前缀和
    for(int i=1;i<=alls.size();i++){
        sum[i]+=sum[i-1]+arr[i];
    }
    //询问前缀和
    for(auto t:query){
        int l=find(t.first),r=find(t.second);
        cout<<sum[r]-sum[l-1]<<endl;
    }
    return 0;
    
}
```
### java版

```java
	static int[] arr=new int[N];//查询数组
	//离散化
		//可惜java的可变成数组还是挺难用的
	static Integer[] alls=new Integer[N];//离散化后的结果
	static int len=0;//离散化后的长度
	static int find(int x) {//x对应离散化后的下标
		return Arrays.binarySearch(alls, 0, len, x)+1;//从1开始
	}

	//离散化操作
			List<Integer> tmp=new ArrayList<>();
			for(int i=0;i<n;++i) {
				arr[i]=Integer.parseInt(br.readLine());
				tmp.add(arr[i]);
			}
			tmp=new ArrayList<>(new TreeSet<>(tmp));
			len=tmp.size();
			alls=tmp.toArray(new Integer[0]);
```

> 需要注意的是，为了避免返回`Object`类型的数组，可以**传递一个指定类型的数组**作为参数，如果数组大小不够，则会创建一个新数组。



## 区间合并

> 不知道为毛，感觉很容易忘
>
> 如果忘了，左边先随便画个区间，然后右边画多个同(左|右)端点的区间，试试有没有影响

```
给定 n 个区间 [li,ri]，要求合并所有有交集的区间。
注意如果在端点处相交，也算有交集。
输出合并完成后的区间个数。
```
![区间合并图.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_f0b56c6152-区间合并图.jpg) 
```c++
//另一种贪心常用策略：左端点排序
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n;
struct Range{
    int l,r;
    bool operator<(const Range &other) const{
        return l<other.l;//用左端点来排序
        //右端点后面会更新
    }
};
int merge(vector<Range> &a){//直接传实参
//形参复制需要时间
    sort(a.begin(),a.end());//别忘记排序了
    vector<Range> res;
    //记住下面这种形式
    int be=a[0].l,ed=a[0].r;//开始和结束
    for(auto &x:a){//按编号顺序遍历真个数组
        if(ed<x.l){//已经连不上了
            res.push_back({be,ed});
            be=x.l,ed=x.r;
        }else{
            ed=max(ed,x.r);//这里一定要注意，合并后取大的区间
        }
    }
    res.push_back({be,ed});
        //别忘记最后一段区间:
                //1.合并了，不会被记录
                //2.没被合并，不会被记录
    
    return res.size();
}
int main(){
    cin>>n;
    vector<Range> a;
    for(int i=0;i<n;i++){
        int l,r;cin>>l>>r;
        a.push_back({l,r});
    }
    cout<<merge(a);
    return 0;
}
```
> ==**特别注意最后一段区间，一般都是要特判的**==，你无论那种情况都不会被记录

## 递归

### 处理括号问题

> 类似这种括号匹配的问题，需要借助栈这个数据结构，而递归函数就是天然的栈

[AcWing 1225. 正则问题（蓝桥杯辅导课） - AcWing](https://www.acwing.com/activity/content/problem/content/9758/)



# 数据结构

## 单链表

实现一个单链表，链表初始为空，支持三种操作：

1.  向链表头插入一个数；
2.  删除第 $k$ 个插入的数后面的数；
3.  在第 $k$ 个插入的数后插入一个数。

现在要对该链表进行 $M$ 次操作，进行完所有操作后，从头到尾输出整个链表。

**注意**:题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。
![单链表.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_3e9b756452-单链表.jpg) 
（有错别字，节点要改为结点）

```c++
/*
单链表：(数组版)
    (每一个下标就表示一个节点)
    开始时指向-1，表示链表的最后一个元素
    头指针head，指向第一个元素，可以理解为这个链表的标志（名字之类）
    idx表示但前用到哪个元素（正要用但没开始）
    （然后我们一般是从0开始存）
    e[i]用来存节点i的值
    ne[i]表示节点i的下一个节点编号(指向)

（指向操作用head，ne[]完成）
头指针指向第一个节点，后面的元素指向下一个元素，最后的元素指向-1
(存值用e[i]来操作)
*/
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;
//单链表
//初始
int head=-1,idx=0;//开始时head指向-1，这里idx指向1会更好一点
int e[N],ne[N];
//各种操作
//链表头插入
void add_to_head(int x){
    e[idx]=x;ne[idx]=head;head=idx++;
}
//在第k个后面插入x
void add(int k,int x){
    e[idx]=x;ne[idx]=ne[k];ne[k]=idx++;
}
//删除第k个数后面的数（从0开始），但题目是从1开始也就是说后面要-1
void remove(int k){
    if(k==-1){
        head=ne[head];
    }else{
        ne[k]=ne[ne[k]];//直接连下一个
    }
}
int main(){
    int n;
    cin>>n;
    while(n--){
        char c;
        cin>>c;
        if(c=='H'){
            int x;
            cin>>x;
            add_to_head(x);
        }else if(c=='D'){
            int k;
            cin>>k;
            remove(k-1);
        }else{
            int k,x;
            cin>>k>>x;
            add(k-1,x);
        }
    }
    for(int i=head;i!=-1;i=ne[i]){
        cout<<e[i]<<" ";
    }
    return 0;
}
```
## 双链表
实现一个双链表，双链表初始为空，支持 $5$ 种操作：

1.  在最左侧插入一个数；
2.  在最右侧插入一个数；
3.  将第 $k$ 个插入的数删除；
4.  在第 $k$ 个插入的数左侧插入一个数；
5.  在第 $k$ 个插入的数右侧插入一个数

现在要对该链表进行 $M$ 次操作，进行完所有操作后，从左到右输出整个链表。

**注意**:题目中第 $k$ 个插入的数并不是指当前链表的第 $k$ 个数。例如操作过程中一共插入了 $n$ 个数，则按照插入的时间顺序，这 $n$ 个数依次为：第 $1$ 个插入的数，第 $2$ 个插入的数，…第 $n$ 个插入的数。

 ![双链表.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_d6d4767852-双链表.jpg)

  **先在对k号点操作前，完成除了k号点以外所有的操作就行**  

```c++
/*
双链表：既有前驱又有后继
        （单链表只有后继）
初始化：只有两个点互相连接，
        r[0]=1,l[1]=0,idx=2;
        （0号点和1号点分别代表左右端点，注意真正的第一个点是从2开始的）
        (实际中并没左右端点，你可以等价于单链表中-1)
         一定要注意从2开始
删除k号点：1.【右边的左边】等于【左边】
           2.【左边的右边】等于【右边】
在第k号点的右边插入：
        存值
        1.先更新插入点的后继
        2.在更新【k号点的后继】的前驱
        3.更新【k号点的后继】
    （后面的的操作都是用这个修改而来）
*/
#include<bits/stdc++.h>
using namespace std;

const int N=1e5+10;

int l[N],r[N],idx,e[N];
void init(){
    r[0]=1;//左端点
    l[1]=0;//右端点
    idx=2;
}
void remove(int k){//删除
    r[l[k]]=r[k];
    l[r[k]]=l[k];
}
void add(int k,int x){
    e[idx]=x;
    l[idx]=k;r[idx]=r[k];
    l[r[k]]=idx;
    r[k]=idx++;
}
int main(){
    int m;
    cin>>m;
    init();//别忘了
    while(m--){
        string op;
        cin>>op;
        if(op=="L"){
            int x;
            cin>>x;
            add(0,x);
        }else if(op=="R"){
            int x;
            cin>>x;
            add(l[1],x);
        }else if(op=="D"){
            int k;
            cin>>k;//注意是从2开始
            remove(k+1);
        }else if(op=="IL"){
            int k,x;
            cin>>k>>x;
            add(l[k+1],x);//在k的左侧相当于在k前驱的右侧
        }else{
            int k,x;
            cin>>k>>x;
            add(k+1,x);
        }
    }
    for(int i=r[0];i!=1;i=r[i]){//做到右，右端点为1
        cout<<e[i]<<" ";      
    }
    return 0;
}
```
## 栈
**数组模拟版**
```c++
/*
栈就是先进先出
我这里就从1开始了
*/
#include<iostream>
using namespace std;
const int N=1e5+10;
int st[N],tt;//st就是模拟栈，tt是指针，指向栈顶
void push(int x){
    st[++tt]=x;
}
void pop(){
    tt--;
}
bool empty(){
    if(tt){//不是0就表示空
        return 0;
    }else{
        return 1;    
    }
}
int query(){
    return st[tt];
}
int main(){
    int m;
    cin>>m;
    while(m--){
        string op;
        cin>>op;
        if(op=="push"){
            int x;
            cin>>x;
            push(x);
        }else if(op=="query"){
            cout<<query()<<endl;
        }else if(op=="pop"){
            pop();
        }else{
            if(empty()){
                cout<<"YES";
            }else{
                cout<<"NO";
            }
            cout<<endl;
        }
    }
    return 0;
}
```

**stl版**
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    stack<int> s;
    int m;
    cin>>m;
    while(m--){
        string op;
        cin>>op;
        if(op=="push"){
            int x;
            cin>>x;
            s.push(x);
        }else if(op=="query"){
            cout<<s.top()<<endl;
        }else if(op=="pop"){
            s.pop();
        }else{
            if(s.empty()){
                cout<<"YES";
            }else{
                cout<<"NO";
            }
            cout<<endl;
        }
    }
    return 0;
}
```
### 表达式求值

给定一个表达式，其中运算符仅包含 `+,-,*,/`（加 减 乘 整除），可能包含括号，请你求出表达式的最终值。

 **运算时，保险起见最好都用`while`** 

**注意：**

-   数据保证给定的表达式合法。
-   题目保证符号 `-` 只作为减号出现，不会作为负号出现，例如，`-1+2`,`(2+2)*(-(1+1)+2)` 之类表达式均不会出现。
-   题目保证表达式中所有数字均为正整数。
-   题目保证表达式在中间计算过程以及结果中，均不超过 $2^{31}-1$。
-   题目中的整除是指向 $0$ 取整，也就是说对于大于 $0$ 的结果向下取整，例如 $5/3=1$，对于小于 $0$ 的结果向上取整，例如 $5/(1-4) = -1$。
- C++和Java中的整除默认是向零取整；Python中的整除`//`默认向下取整，因此Python的`eval()`函数中的整除也是向下取整，在本题中不能直接使用。
  ![表达式求职.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_d8753e1d52-表达式求职.jpg) 
  ![表达式求值2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_df6bb98152-表达式求值2.jpg) 

  #### **哈希表stl**
```c++
//初始
	unordered_map<char,int> h{{'+',1},{'-',1},{'*',3}};
			   //这里应该是pair类型
//插入
	h.emplace('/',100);
//修改value
	auto it=h.find('/');//找这个值的位置，返回的是指针，若没有返回end指针
	if(it!=h.end()){//当前值是否存在
		it->second=3;//访问当前地址的成员，等价于(*it).second;
//		(*it).second=3;
	}
//访问
	cout<<h['/']<<endl;
//删除，(不过是假删)，但是你用c++11遍历时并不会遍历到
	h.erase('/');


//遍历
	for(auto x:h){
		cout<<x.first<<" "<<x.second<<endl;
	}
	for(auto ite=h.begin();ite!=h.end();ite++){
		cout<<ite->first<<" "<<ite->second<<endl;
	}

```

```c++
这里涉及到运算符优先级和结合性，
    遇到同优先级的先算前面还是后面

/*
哎呀，这题花了好长的时间（但感觉还是挺有必要的）
需要一丁点哈希表的运用（不多，但还是去大概看了看哈希表stl）
（主要用在优先级的判断）
*/
/*
首先我要先忽略掉括号，因为括号比较特殊（能改变优点级）
（后面在看）
{
栈模拟二叉树（感觉这个也是不怎么好懂）：

当只有加减乘除的式子，
    （根据y总的视频）
    就是一个二叉树，叶子节点是数，节点是运算符
    （根节点就是最上面的那个）

    然后发现：1.节点下面都是叶子节点时
                （没有在连其他东西），才能够运算
              2.越往下面的节点优先级更高，
    根据这个特性来判断：
        当前运算符（节点）优先级>=上面节点的优先级，
        这时就能够运算了

    转化栈：
    1.需要两个栈：一个用来存数，一个又来存运算符
    2.判断栈顶优先级是否>=下个运算符，
        是就运算
    3.遇到'('做分隔符存入

加入括号要将括号中的式子全算完，才能够接着运算，
这时我们可以将'('当成分隔符，隔开前面的式子，到')'才能回复原在的运算
}

模拟式的理解看这篇题解：
https://www.acwing.com/solution/content/40978/
*/
#include<bits/stdc++.h>
using namespace std;
unordered_map<char,int> pr{{'+',1},{'-',1},{'*',2},{'/',2}};//优先级
stack<int> num;
stack<char> op;
void eval(){//计算
    int b=num.top();num.pop();
    int a=num.top();num.pop();//先进后出，前面在下面
    char c=op.top();op.pop();
    int res;
    if(c=='+'){
        res=a+b;
    }else if(c=='-'){
        res=a-b;
    }else if(c=='*'){
        res=a*b;
    }else{
        res=a/b;
    }
    num.push(res);
}
int main(){
    string s;
    cin>>s;
    for(int i=0;s[i];i++){
        if(isdigit(s[i])){//存数字
            int j=i,t=0;
            while(isdigit(s[j])){
            //判断是否为数字，等价于'0'<=s[j]<='9'
                t=s[j]-'0'+t*10;
                j++;
            }
            i=j-1;//注意要减1
            num.push(t);
        }else if(s[i]=='('){
            //遇到左括号时，做分隔符
            op.push(s[i]);
        }else if(s[i]==')'){
            //就括号中式子全部算完
            while(op.top()!='('){
                eval();
            }
            op.pop();
        }else{
            //下一个符号（节点）,看是否要运算
            /*
            这里为什么要while呢？
                （根据上面的特性，要都只把节点下面的树都遍历完，才能下一个运算）
                （上面这个太抽象，别看了）
                感觉就是为了满足同优先级从左到右算
                (不然后面会出优先级的问题)
                例如：1-2*3+4
                    先算2*3=6，然后发现后面的'+'和前面的'-'优先级相同，
                    所以先将左边的算了,
                    但是如果是if的话6+4会先算，再算1-（6+4）
                    最好结果为-14，显然有问题(习惯上就是左边的先算完在右边麻)
                    （这里仔细看一下）
            */
            while(op.size()&&op.top()!='('&&pr[op.top()]>=pr[s[i]]){
            //注意，不然后溢出,先判断有没有符号
                eval();
            }
            op.push(s[i]);
        }
    }
    while(!op.empty()){
        eval();
    }
    cout<<num.top();
    return 0;
}
```
## 队列
**数组模拟**
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int q[N],hh,tt=-1;//第一个从1开始
int main(){
    int m;
    cin>>m;
    while(m--){
        string s;
        cin>>s;
        if(s=="push"){
            int x;
            cin>>x;
            q[++tt]=x;
        }else if(s=="empty"){
            if(hh<=tt){
                cout<<"NO\n";
            }else{
                cout<<"YES\n";
            }
        }else if(s=="query"){
            cout<<q[hh]<<endl;
        }else if(s=="pop"){
            hh++;
        }
    }
    return 0;
}
```

**stl**


```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int main(){
    int m;
    cin>>m;
    queue<int> q;
    while(m--){
        string s;
        cin>>s;
        if(s=="push"){
            int x;
            cin>>x;
            q.push(x);
        }else if(s=="empty"){
            if(!q.empty()){
                cout<<"NO\n";
            }else{
                cout<<"YES\n";
            }
        }else if(s=="query"){
            cout<<q.front()<<endl;
        }else if(s=="pop"){
            q.pop();
        }
    }
    return 0;
}
```
## 单调栈
```
题：找左边第一个比他小的数
```
```c++
/*
单调栈：栈内的元素具有严格的单调性

（感觉有点贪心思想）
对于相邻的数：
    1.当a[i-1]>=a[i],
      要找左边最小的数，显然a[i]会比a[i-1]好，放a[i]即可
    2.当a[i-1]<a[i]时，
      a[i]依然可能是左边最小的数
现在拓展到全局：
    当a[x]>=a[y],x<y
    放y显然更好，
*/
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;
    cin>>n;
    stack<int> s;
    for(int i=0;i<n;i++){
        int x;
        cin>>x;
        while(!s.empty()&&s.top()>=x){
            s.pop();
        }
        if(s.empty()){
            cout<<"-1 ";
        }else{
            cout<<s.top()<<" ";
        }
        s.push(x);
    }
    return 0;
}
```
## 单调队列
**滑动窗口**
```
题：一个长度为k的滑动的窗口，每次输出窗口的最大最小值
```

 **问题分解，先找最大值一个问题，最小值一个问题** 

```c++
以输出最小值为例：
    如果前数比队列的前一个小，那么最小值就不可能是前面的，这样不断出队
/*
单调队列：满足严格单调性的队列
    （但是稍有不同的是队头和队尾都是要维护的，因此用数组模拟会好点）
    （当然也有deque的库函数，但好像不是很有必要）
    （其实挺像单调栈的，但这里找的是最值）
对于这题的特性：
    当要找窗口最小值时，
    例如窗口的值为【3，-1，-3】
    由于-3在-1的后面，且比-3大，因此不可能最小值
    我们需要将一些冗余点（不可能的点）给去掉，
    因此采用单调队列
    （好处：队头就是最值，复杂度很低）
    维护：1.要加入一个新数时，把比他大的都可以去掉，其成为新的队尾
          2.队头还要看是否在窗口内部（需要下标）

然后这里队列会发现还需要用到下标，用下标表示数会比较方便
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
int a[N];
int q[N],hh=0,tt=-1;//数组模拟队列
int main(){
    int n,k;
    cin>>n>>k;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    //输出窗口最小值
    for(int i=0;i<n;i++){
        //队头是否在窗口内
        // cout<<i-k<<" "<<q[hh]<<endl;
        if(hh<=tt&&q[hh]<=i-k){//很多数据结构都是要是否为空的
            hh++;
        }
        //维护队尾
        while(hh<=tt&&a[q[tt]]>a[i]){
            tt--;
        }
        
        q[++tt]=i;//入队
        if(i>=k-1)cout<<a[q[hh]]<<" ";
        // cout<<hh<<" "<<tt<<" "<<a[q[hh]]<<" "<<a[q[tt]]<<endl;
    }
    cout<<endl;
    //输出窗口最大值
    hh=0,tt=-1;//敲了，别忘了
    for(int i=0;i<n;i++){
        //队头是否在窗口内
        // cout<<i-k<<" "<<q[hh]<<endl;
        if(hh<=tt&&q[hh]<=i-k){//很多数据结构都是要是否为空的
            hh++;
        }
        //维护队尾
        while(hh<=tt&&a[q[tt]]<a[i]){
            tt--;
        }
        
        q[++tt]=i;//入队
        if(i>=k-1)cout<<a[q[hh]]<<" ";
        // cout<<hh<<" "<<tt<<" "<<a[q[hh]]<<" "<<a[q[tt]]<<endl;
    }
    return 0;
}
```
## 字符串匹配kmp

**string自带函数（但是会超时）(暴力)**

```c++
//肯定是要掌握的，平时应该够用了
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    string a,b;
    cin>>n>>a>>m>>b;
    int pos=b.find(a);
    while(pos!=-1){
        cout<<pos<<" ";
        pos=b.find(a,pos+1);
    }
    return 0;
}
```


## kmp算法
操作图
![kmp1.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_4b4c202552-kmp1.jpg) 
![kmp2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_6fb83b8252-kmp2.jpg) 
```
/*
暴力做法是肯定要会的（原理+find函数）
{
    接下来几乎所有的讲法就是：(等到后面有图这个就懂了)
        首先是一个字符串S（要匹配的对象）放上面，
            要找的字符串P放下面
        然后是一个匹配窗口进行a[i]和a[j]的匹配（也可能不一样，但这个是小问题）
        匹配上了窗口就向后移动（i++，j++）
        后面我们是将S固定，匹配不上都会移动P（实在不行在动i）
        
        （移动的过程是必须要懂的）
}
```


----------


```c++
/*
(需要着重强调的暴力是i,j都会回溯，而kmp只需要回溯j)
kmp算法：
（这样描述其实不什么好懂，最好看一下画的那张图）
（移动j的过程，相当于移动P）
（这里模板的匹配窗口是S[i]和P[j+1]进行匹配）(这个一定要牢记)
1.S和P匹配的过程：
    1）S[i]==P[j+1]时
        这时候两个指针都往下走
        就是匹配窗口往下走
    2）S[i]！=P[j+1]
        这时两字符串匹配过的内容是已知的，上下是完全一样，
        这时候只要移动下面的P串进行匹配（前面的结论）
        只需要将最大相等的前缀移动到与后缀这next[j]
2.最大公共前后缀和next数组：（与上面类似，但只要看这个位置）
    （next数组是用来存最大公共前后缀的长度，
        同时是前缀的最后一位的位置）
    这里的对象只有P
    是P[1~i]的前缀和后缀的匹配
    上面的是后缀，而我们移动的是下面的前缀
    （跟上面不同是我们只要看这个窗口的结果就行了）
    现在是普遍的情况，假设这里前面的已经是匹配的了
    1）后缀[i]==前缀[j+1]时
        j++;
        next[i]=j;
    2)后缀[i]!=前缀[j+1]时
        这时我们需要移动前缀
        也就是将【前缀的前缀】移动到【前缀的后缀】查看匹配的的结果
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,N1=1e6+10;//next数组
int ne[N];//next数组
char p[N];
char s[N1];
int main(){
    int n,m;
    cin>>n>>p+1>>m>>s+1;//这个要会，从1开始记录
    //创建next数组
    for(int i=2,j=0;p[i];i++){//从2开始，1没有意义
        while(j&&p[j+1]!=p[i]){
            j=ne[j];//将前缀移到后缀这
        }
        if(p[j+1]==p[i]){
            j++;//匹配窗口往后（后面还有个i++）
        }
        ne[i]=j;//记录下前缀的最后一个位置
    }
    //开始真正的匹配过程S,P
    for(int i=1,j=0;s[i];i++){
        while(j&&p[j+1]!=s[i]){
            j=ne[j];//将前缀移到后缀这
        }
        if(p[j+1]==s[i]){
            j++;//移动匹配窗口  
        }
        // cout<<i<<" "<<j<<endl;
        if(j==n){
            //此时已经匹配完了，开始下一个的匹配
            cout<<i-j<<" ";
            j=ne[j];//还是将前缀移到后缀这
        }
    }
    
    
    return 0;
}
```
## 字符串前缀哈希法
```c++
//学完哈希表后可以看一下
//采用字符串哈希，时间复杂度应该是O(n),能过,而且好像还快点
#include<bits/stdc++.h>
using namespace std;
typedef unsigned long long ull;
const int N=1e5+10,M=1e6+10,P=131;
ull h[M],p[M],n,m;
char s[M],a[N];
int get(int l,int r){
    return h[r]-h[l-1]*p[r-l+1];//对齐
}
int main(){
    scanf("%d%s%d%s",&n,a+1,&m,s+1);
    //初始化
    p[0]=1;
    for(int i=1;s[i];i++){
        h[i]=h[i-1]*P+s[i];
        p[i]=p[i-1]*P;
    }
    //要找的这个串的hash值
    int find=0;
    for(int i=1;a[i];i++){
        find=find*P+a[i];
    }
    //开始匹配
    for(int i=1,j=n;s[j];i++,j++){
        if(find==get(i,j)){
            cout<<i-1<<" ";
        }
    }
    return 0;
}
```
## 字典树
**trie字符串统计**
```
题：统计一个字符串（只用小写字母）出现了多少次
字符串的长度不超过1e5
```
**哈希表版**
```c++
/*
用哈希表版的存下标记法(统计出现次数)，比较好做
（用来查东西非常好用）
现在还没学完，所以这里就用stl
用一个key去查value
unordered_map<>  ;
*/
#include<bits/stdc++.h>
using namespace std;
int main(){
    unordered_map<string,int> h;
    int n;
    cin>>n;
    while(n--){
        char op;
        cin>>op;
        if(op=='I'){
            string s;
            cin>>s;
            if(h.find(s)!=h.end()){
                h[s]++;
            }else{
                h.emplace(s,1);
            }
        }else{
            string s;
            cin>>s;
            cout<<h[s]<<endl;
        }
    }
    return 0;
}
```


**字典tire树版**
![图模拟.jpg](https://cdn.acwing.com/media/article/image/2023/05/07/246003_f225899dec-图模拟.jpg) 

```c++
/*
字典树：
(这个算法其实挺抽象，建议用采用画图模拟的方式理解)
用法：高效的地存储和查找字符串集合的数据结构，不重不漏
缺点：时间复杂度很低，但是大部分情况浪费很多空间
（
  这个使用数组模拟的多叉树，
  同时其实本质上跟邻接表也也挺像的
）

首先需要讲明的是：
    这里每个节点都表示是一个【字母】，而且这些节点是可以共用的
    从根节点（节点0）到这个节点的路径，表示的是一个单词或是前缀
int son[N][26];//用来指向[下一个节点]，同时也表示[下个节点状态],0~25对应a~z
    son[p][u]=i;
        p是当前节点编号;特别当p=0,为根节点，表示开头状态
        u是下一个节点的状态，对应字母【'a'+u】;
        i是下一个节点的下标;特别的i=0时，表示这个状态为空
int cnt[N];
    cnt[i]=x;
        表示以【节点i】结尾的单词有x个（结合上面的讲明）
int idx=0;
    跟链表的含义一样
    表示的是新节点的下标分配器
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
//字典树创建
int son[N][26],cnt[N],idx;
void insert(string &s){
    int p=0;
    for(int i=0;s[i];i++){
        int u=s[i]-'a';
        if(!son[p][u]){//没有就补创
            son[p][u]=++idx;//创建新的节点，注意++在前
        }
        p=son[p][u];//下一个节点
    }
    cnt[p]++;//到这个节点就能结束了
}
int query(string &s){//查询这个单词个数
    int p=0;
    for(int i=0;s[i];i++){
        int u=s[i]-'a';
        if(!son[p][u]){//没有这个前缀就可以提早结束了
            return 0;
        }
        p=son[p][u];
    }
    return cnt[p];
}
int main(){
    int n;
    cin>>n;
    while(n--){
        char op;
        cin>>op;
        if(op=='I'){
            string s;
            cin>>s;
            insert(s);
        }else{
            string s;
            cin>>s;
            cout<<query(s)<<endl;
        }
    }
    return 0;
}
```
**最大异或和**
```
题：给出n个整数，找出其中哪一对求异或和最大
```

![最大异或和1.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_7366707252-最大异或和1.jpg) 
![最大异或和2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_76f7f31b52-最大异或和2.jpg) 
```c++
#include<bits/stdc++.h>
using namespace std;
const int M=1e5+10;
int a[M];
//创建字典树，方便查找
const int N=3.1e6+10;
    //因为一共有1e5个数，每个数的二进制位有31个，那么假设他恰好每次都是一条新的分支就是31*1e5,实际上是不可能的
int son[N][2];
    //son[p][u]=i:p表示当前节点下标；u表示下一个节点状态0/1；i表示下一个节点的下标
    //如果只看当前节点的话，表示0/1，若结合根节点的话，表示的一个31位二进制数的前缀或本身
int idx;
    //表示新节点的下标分配器
//这里不需要cnt[N],记录结束下标，因为每个数都是31位，到这个深度时都会自动结束
/*
这里是用每一位的最优解
这里是从二进制的最高位出发：
    假设二进制数有x=(001)2,剩下两个数(101)2和(010)2
    显然最高位对整体的影响会更大，从最低位出发找的就是(010)2了
*/
void insert(int x){//建trie树
    int p=0;//开始时，都是指向根节点
    for(int i=30;i>=0;i--){
    //这i>=0还可以写成(~i),因为根据计算机二进制表示只有-1是全为1的
        int u=x>>i&1;//左移的优先级比按位与高
        if(!son[p][u]){//没有这个节点就新建
            son[p][u]=++idx;
        }
        p=son[p][u];
    }
}
int query(int x){//寻找当前数字的最大异或对
    int res=0,p=0;
    for(int i=30;i>=0;i--){
        int u=!(x>>i&1);//取个非，就是当前的最优解
        if(son[p][u]){//如果存在,走下去
            res+=1<<i;
            p=son[p][u];
        }else{//不存在，只能勉为其难走另一条
            p=son[p][!u];
        }
    }
    return res;
    
}
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
        insert(a[i]);
    }
    int ans=0;
    for(int i=0;i<n;i++){
        ans=max(ans,query(a[i]));
    }
    cout<<ans;  
    return 0;
}
```
## 并查集

 **最好特判一下是不是一个集合，防止一些特殊情况** 

**合并集合只要对根节点操作就行**

--------

### 是否在一个集合中

**合并集合**
一共有 $n$ 个数，编号是 $1 \sim n$，最开始每个数各自在一个集合中。

现在要进行 $m$ 个操作，操作共有两种：

1.  `M a b`，将编号为 $a$ 和 $b$ 的两个数所在的集合合并，如果两个数已经在同一个集合中，则忽略这个操作；
2.  `Q a b`，询问编号为 $a$ 和 $b$ 的两个数是否在同一个集合中；
```c++
/*
并查集：
    核心：当前节点指向父节点，用集合的一个元素（宗主）去表示整个集合
    
    初始化：开始时都指向自己（自己就是宗主）
    找宗主同时路径压缩：不断找元素的宗主，同时把宗主赋给自己
    认宗主：p[宗主1]=宗主2（宗主1认宗主2为新宗主）
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
//并查集
int p[N];
int find(int x){//找x的宗主,同时路径压缩
    if(p[x]!=x){//没找到宗主，就往下走
        p[x]=find(p[x]);//这个等于号就是路径压缩，直接将走过的元素都指向宗主
        //哎呀，好笨啊我，这里找的是p[x],找的是父节点的宗主，而不是找x（自己找自己，没有意义）
    }
    return p[x];
}
int main(){
    int n,m;
    cin>>n>>m;
//初始化
    for(int i=1;i<=n;i++){
        p[i]=i;
    }
    char op;
    int a,b;
    while(m--){
        cin>>op>>a>>b;
        if(op=='M'){
            p[find(a)]=find(b);
            //集合合并，把【集合1（a）的宗主】指向【集合2（b）的宗主】
        }else{
            if(find(a)!=find(b)){
                cout<<"No\n";
            }else{
                cout<<"Yes\n";
            }
        }
    }
    return 0;
}
```
### 求集合中的点数

**连通块中点的数量**

==(要特判一下是不是在同一个集合中，才加另一个集合的点数)==

给定一个包含 $n$ 个点（编号为 $1 \sim n$）的无向图，初始时图中没有边。

现在要进行 $m$ 个操作，操作共有三种：

1.  `C a b`，在点 $a$ 和点 $b$ 之间连一条边，$a$ 和 $b$ 可能相等；
2.  `Q1 a b`，询问点 $a$ 和点 $b$ 是否在同一个连通块中，$a$ 和 $b$ 可能相等；
3.  `Q2 a`，询问点 $a$ 所在连通块中点的数量；
```c++
/*
可以转化为并查集：
    如果是同一个连通块，就是在同一个集合。
    就是要额外记录下，点的个数（以宗主的个数为整个集合的个数）*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
//并查集
int p[N];
int cnt[N];//需要额外记录点的个数
int find(int x){//找宗主
    //不是宗主就找爸爸，同时宗主成为新爸
    if(x!=p[x]){
        p[x]=find(p[x]);//x的爸爸是p[x],所以找的是p[x]
    }
    return p[x];//找到宗主就返回，同时赋值
}
int main(){
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cnt[i]=1;//一开始只有自己
        p[i]=i;//开始时，自己就是自己的宗主
    }
    while(m--){
        string op;
        cin>>op;
        if(op=="C"){
            int a,b;
            cin>>a>>b;
            if(find(a)==find(b)){
                continue;
            }
            cnt[find(b)]+=cnt[find(a)];//O(1)就是可以为所欲为
            //唉，服了我自己了，这两句我颠倒了，但是要加的是之前的
            p[find(a)]=p[find(b)];//b是新宗主
            
            // cout<<find(b)<<" "<<cnt[find(b)]<<endl;
            
        }else if(op=="Q1"){
            int a,b;
            cin>>a>>b;
            if(find(a)==find(b)){
                cout<<"Yes\n";
            }else{
                cout<<"No\n";
            }
        }else if(op=="Q2"){
            int a;
            cin>>a;
            cout<<cnt[find(a)]<<endl;
        }
    }
    // for(int i=1;i<=n;i++){
    //     cout<<cnt[i]<<" ";
    // }
    return 0;
}
```
### 带权并查集

![并查集1.jpg](https://cdn.acwing.com/media/article/image/2023/05/12/246003_bf00e359f0-并查集1.jpg)

(这里联通块的有点问题：要特判一下是不是一个集合中，才加点数) 
![并查集2.jpg](https://cdn.acwing.com/media/article/image/2023/05/12/246003_c7d425acf0-并查集2.jpg) 
![并查集3.jpg](https://cdn.acwing.com/media/article/image/2023/06/30/246003_3e6479f417-并查集3.jpg) 
**食物链（带权值的并查集)**

```
题：三类动物 A,B,C。A  吃 B，B 吃 C，C 吃 A。
给出几句话，以前的话为准，判断这些话是否为真
```
```c++
/*
非常巧妙的一题：
这题是带权值并查集：
    用到根节点的距离来表示与根节点的相对关系，同时就能够推出与其他点的关系

假设到根节点的距离取余3：
    1）余0时，表示与根节点同类
    2）余1时，表示吃根节点
    3）余2时，表示被根节点吃
点一点例：a余1，b余2，那么b能够吃掉a

判断是否为真话：
前面的是真话
1.如果不是同一个根节点上：
    则无法判断真伪，则当成真
2.是：
    判断其格子与根节点的关系
    
当为真话就加入这个集合内

这里需要特别强调的是：
    这里的权值是当前点到父节点的距离，
    当要用到时就会转化到根节点的距离（路径压缩，根节点成为新的父节点）
*/
#include<bits/stdc++.h>
using namespace std;
const int N=5e4+10;
int n,k;
int ans;
//带权值的并查集
int p[N],d[N];//当前点，前面存的是父节点，后面存的是权值
void init(){//初始化,cnt开始时默认为0
    for(int i=1;i<=n;i++){
        p[i]=i;
    }
}
int find(int x){
    //找宗主，同时宗主成为新的父节点，会更新权值
    if(x!=p[x]){//父节点不是宗主，接着往下找
        int t=p[x];//先记录下父节点，因为一会儿会丢失
        p[x]=find(p[x]);//更新为宗主
        d[x]+=d[t];//回来时，父节点已经是指向宗主，权值也更新了
        //上面的操作要好好想清楚
    }
    return p[x];
}
int main(){
    cin>>n>>k;
    init();
    while(k--){
        int op,x,y;
        cin>>op>>x>>y;
        if(x>n||y>n){
            ans++;
            continue;
        }
        if(op==2&&x==y){
            ans++;
            continue;
        }
        int a=find(x),b=find(y);
        if(op==1){//判断同类
            
            if(a==b&&(d[x]-d[y])%3){//先判断为假的情况
                ans++;
            }else if(a!=b){//两个集合合并
                p[a]=b;//b成为了新的宗主
                d[a]=d[y]-d[x];//这里需要画图才能理解
            }
        }else{
            if(a==b&&(d[x]-d[y]-1)%3){//y能被x吃，说明其各自取余3后，x比y多1
                ans++;
            }else if(a!=b){
                p[a]=b;
                d[a]=1-d[x]+d[y];
            }
        }
    }
    cout<<ans;
    return 0;
}
```


## set集合

(这里先把常用的写一下)

[【总结】C++ 基础数据结构 —— STL之集合（set）用法详解_c++ stl set-CSDN博客](https://blog.csdn.net/weixin_44668898/article/details/102089892)

```c++
set<类型> s;
unordered<类型> h;
s.insert(元素);//插入元素
s.count(元素)；//当存在时返回1，不存在返回0
s.lower_bound(k)			//返回一个迭代器，指向键值大于等于k的第一个元素
s.upper_bound(k)			//返回一个迭代器，指向键值大于k的第一个元素
s.size()					//集合中元素的数目
s.empty()					//如果集合为空，返回true，否则返回false
s.erase()					//删除集合中的元素
s.find(k)					//返回一个指向被查找到元素的迭代器
//遍历：
for(auto t:s)
	cout<<t<<" ";
```



## 堆

### 小根堆（数组模拟版）

![堆1.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_d3ebb6ce52-堆1.jpg) 
建树那边，这里写的比较复杂，可以简单理解就是从下往上：一层一层让有子结点的，都保证小的在这个位置上（先让子堆排好序，后面他们的父结点用down也能排好序）
![堆2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_ec14f29252-堆2.jpg) 

```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
//小根堆(优先队列):性质最小值在前面
/*（实现是用数组模拟，所以最好画图）
这是一个完全二叉树（类似线段树）
    除了最后一层无任何子节点其他都有两个子节点
*/
int h[N],idx;//idx从1开始比较方便
//注意这里idx才是表示真正的个数，不是n
void down(int x){//从第x个节点开始往下沉
    //这里不需要碰到任意元素，所以down够了
    int t=x;//寻找本身和左右儿子间的最小值
    if(x*2<=idx&&h[x*2]<h[t]){
        //这里用了逻辑的短路计算，首先要确定有左右儿子，否则可能会数组越界
        t=x*2;
    }
    if(x*2+1<=idx&&h[x*2+1]<h[t]){
        t=x*2+1;
    }
    if(t!=x){
        swap(h[x],h[t]);//交换堆中的值
        down(t);
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>h[i];
    }
    idx=n;
    //建树
    for(int i=n/2;i;i--){
    /*i从n/2~1，
        表示从最后一个父节点往前面遍历，叶子节点不用down
        同时这样能够保证每个节点都不重不漏的遍历到
        时间复杂度o(n)(这里看y总20分钟后)
      还有个小问题：为什么需要从后往前呢？
        因为结点down，如果儿子结点换上去，那么之后都不会影响到（这里好好想想）
    */
        down(i);
    }
    while(m--){
        //1.不断输出最小的值
        cout<<h[1]<<" ";
        //2.然后删除最小值
        h[1]=h[idx];//把最后一个元素（属于最后一层）覆盖掉第一个
        idx--;//把最后一个删掉
        down(1);//把最后一个往下沉，会更新沿途的值
    }
    return 0;
}
```
### stl

```c++
#include<queue>
#include<iostream>
#include<vector>
using namespace std;
const int N=1e5+10;
int n,m;
int main(){
    cin>>n>>m;
    priority_queue<int,vector<int>,greater<int>> q;//注意默认大值优先
    while(n--){
        int x;cin>>x;
        q.push(x);
    }
    while(m--){
        cout<<q.top()<<" ";
        q.pop();
    }
    return 0;
}
```
### 模拟堆（涉及到第k个数）

维护一个集合，初始时集合为空，支持如下几种操作：

1.  `I x`，插入一个数 $x$；
2.  `PM`，输出当前集合中的最小值；
3.  `DM`，删除当前集合中的最小值（数据保证此时的最小值唯一）；
4.  `D k`，删除第 $k$ 个插入的数；
5.  `C k x`，修改第 $k$ 个插入的数，将其变为 $x$；

现在要进行 $N$ 次操作，对于所有第 $2$ 个操作，输出当前集合的最小值。

![模拟堆1.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_dc5dbc1852-模拟堆1.jpg) 
![模拟堆2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_e18e5ed252-模拟堆2.jpg) 
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
//堆（需要标记是第几个的）
int h[N],hp[N],ph[N],idx;//从1开始
int m;
/*
h数组是用来存结点具体的值的
hp数组表示 堆所对应的指针（其实就是第k个）
ph数组表示 指针对用的堆
idx        与链表中相同是下标分配器
需要特殊说明的是idx不是表示第k个，删除的那些也算
所以需要m来记录
*/
//下面这些操作最好去画个图，表上各个名字
void heap_swap(int a,int b){//换家（注：结点下标不换，表示房子）
    //这里的a，b表示堆中结点的下标
    //交换结点值时不能去影响到他是第几个，因此全部都要交换,顺序没关系
    swap(h[a],h[b]);//值交换,东西换
    swap(hp[a],hp[b]);//住户册换（居民持有）
    //这个【结点a】是【第几个入住的】
    swap(ph[hp[a]],ph[hp[b]]);//换名册换（居委会持有）
    //这个【第几个入住的】是【结点几】
}
//为了简化，所以down和up都写
void down(int x){//下沉结点x
    int t=x;
    if(x*2<=idx&&h[x*2]<h[t]){//短路求职避免越界
        t=x*2;
    }
    if(x*2+1<=idx&&h[x*2+1]<h[t]){
        t=x*2+1;
    }
    if(t!=x){//值变了就往下
        heap_swap(t,x);//交换结点t和结点x的家
        down(t);//结点t接着更新
    }
}
void up(int x){//循环写法
    while(x/2&&h[x/2]>h[x]){
        heap_swap(x/2,x);
        x>>=1;
    }
}
int main(){
    int n;
    cin>>n;
    while(n--){
        string op;
        cin>>op;
        //全部东西都转换为结点
        if(op=="I"){
            int x;
            cin>>x;
            idx++,m++;
            h[idx]=x;
            hp[idx]=m;
            ph[m]=idx;
            up(idx);
        }else if(op=="PM"){
            cout<<h[1]<<endl;
        }else if(op=="DM"){
            // h[1]=h[idx];这里我写错，我没有交换全部的值
            heap_swap(1,idx);
            idx--;
            down(1);
        }else if(op=="D"){
            int k;
            cin>>k;
            k=ph[k];//呜呜，千万注意
            heap_swap(k,idx);
            idx--;
            down(k);
            up(k);
        }else{
            int k,x;
            cin>>k>>x;
            k=ph[k];//这里注意一下，先转化为结点
            h[k]=x;
            down(k);
            up(k);
        }
    }
    return 0;
}
```
### 对顶堆：动态求中位数

> 挺重要的，常考

> 好像也叫二叉堆

![对顶推.png](https://cdn.acwing.com/media/article/image/2024/03/17/246003_6479c1c6e4-对顶推.png)

![](https://cdn.acwing.com/media/article/image/2021/02/05/64845_14476dfb67-F95830359687924963F89380AE7BB7D5.png)

> 注意喽：这两个堆是分开的
>
> 说明：(有序序列的)**左半部在下面，右半部在上面**

**需要满足的性质：**

- 上面所有数>=下面所有的数

- 下面个数最多比下面多1

  > 这个是为了**让中位数始终出现在上面**



基本代码：

```java
//对顶堆=>求中位数
	/* 说明：前半部在下面，后半部在上面
	 * 规则:1.下面所有的元素<=上面所有的元素
	 * 		2.下面的个数最多比上面的多1
	 * 因此中位数是在下面（前半部）
	 * */

//对顶堆
    //前半部
    Queue<Integer> down=new PriorityQueue<>(Collections.reverseOrder());//大根堆
    //后半部
    Queue<Integer> up=new PriorityQueue<>();//小根堆

//构造方法
        if(down.isEmpty()||x<=down.peek()) 
            down.add(x);
        else
            up.add(x);
        //让中位数保持在下面
        if(down.size()>up.size()+1)
            up.add(down.remove());
        if(down.size()<up.size())
            down.add(up.remove());

//输出中位数
	down.peek();
```



[106. 动态中位数 - AcWing题库](https://www.acwing.com/problem/content/108/)

依次读入一个整数序列，每当已经读入的整数个数为奇数时，输出已读入的整数构成的序列的中位数。

---



```java
//对顶堆=>求中位数
	/* 说明：前半部在下面，后半部在上面
	 * 规则:1.下面所有的元素<=上面所有的元素
	 * 		2.下面的个数最多比上面的多1
	 * 因此中位数是在下面（前半部）
	 * */
import java.util.*;
import java.io.*;
public class Main{
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw=new BufferedWriter(new OutputStreamWriter(System.out));
		
		int P=Integer.parseInt(br.readLine());
		String[] ss;
		while(P-- >0) {
			ss=br.readLine().split(" ");
			int num=Integer.parseInt(ss[0]),n=Integer.parseInt(ss[1]);
			bw.write(num+" "+(n+1)/2+"\n");
			int cnt=0;//记录输出了几个中位数，到十个就换行
			
			//对顶堆
				//前半部
			Queue<Integer> down=new PriorityQueue<>(Collections.reverseOrder());//大根堆
				//后半部
			Queue<Integer> up=new PriorityQueue<>();//小根堆
			int h=(n+10)/10;
			//读入
			for(int i=0;i<h;++i) {
				ss=br.readLine().split(" ");
				for(int j=0;j<ss.length;++j) {
					int x=Integer.parseInt(ss[j]);
					
					//对堆顶堆操作
					if(down.isEmpty()||x<=down.peek()) 
						down.add(x);
					else
						up.add(x);
						//让中位数保持在下面
					if(down.size()>up.size()+1)
						up.add(down.remove());
					if(down.size()<up.size())
						down.add(up.remove());
					
					if(j%2==0) {//个数为奇数时输出
						bw.write(down.peek()+" ");
						if(++cnt%10==0) bw.write("\n");
					}
				}
			}
			//不能输出多余的空行，需要特判
			if(cnt%10!=0)
				bw.write("\n");
		}
		bw.flush();
	}
}
```

参考资料：[AcWing 106. 动态中位数 - AcWing](https://www.acwing.com/solution/content/34043/)







## 模拟散列表

**作用：用小区间去表示大区间**
### stl
```c++
#include<unordered_map>
#include<iostream>
using namespace std;
int main(){
    unordered_map<int,int> h;
    int n;cin>>n;
    while(n--){
        char op;cin>>op;
        if(op=='I'){
            int a;cin>>a;
            h[a]++;
        }else{
            int a;cin>>a;
            if(h.find(a)!=h.end()){
                cout<<"Yes\n";
            }else{
                cout<<"No\n";
            }
        }
    }
    return 0;
}
```

```
备注：这两种避免冲突的方法各有各的好处，很难说谁好谁坏，就跟风学y总用开放寻厕法
    拉链法：时间复杂度可能会稍微低一点点，但实现起来难一点
    开放寻厕法：只需要一个一维数组，实现起来相对简单
```
![哈希表1.jpg](https://cdn.acwing.com/media/article/image/2023/06/25/246003_071bd8fa13-哈希表1.jpg) 
![哈希表2.jpg](https://cdn.acwing.com/media/article/image/2023/06/25/246003_0c9cda1c13-哈希表2.jpg) 
### 存储结构：开放寻值法
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=200003;
/*开放寻址法需要将数组开到两三倍（小区间的值域），
  找到大于他的最小质数（这里是用数学整出来的，来保证冲突最少）
*/
int h[N];//初始化时不能在数据范围里面
int find(int x){//作用：找到返回坑位；没找到返回存储位置
    int t=(x%N+N)%N;
    while(h[t]<=1e9&&h[t]!=x){
        t++;
        if(t==N) t=0;//这步不能忘记
    }
    return t;
}
int main(){
    memset(h,100,sizeof h);
    
    int n;scanf("%d",&n);
    while(n--){
        char op[2];int x;
        scanf("%s%d",op,&x);
        int t=find(x);
        if(*op=='I') h[t]=x;
        else{
            if(h[t]==x) puts("Yes");
            else        puts("No");
        }
    }
    return 0;
}
```


### 存储结构：拉链法）（邻接表

```c++
/*
哈希表
    目前来看就是用一个小区间去映射一个较大大区间
    (这里一般采用取余的方法)
    其中会出现一些冲突，
        就是小区间同一个数可能表示大区间中多个数
        因此这里采用拉链法存储结构，来保证不重不漏
时间复杂度在平均状况下为O(1)
*/
//拉链法：
//（其实就是邻接表，表示同一个起点，而这里表示同一个小区的数）
#include<cstring>
#include<iostream>
using namespace std;
const int N=100003;
//这个余数是有讲究的，首先要是质数，然后离2的整数幂远
//邻接表
int h[N],e[N],ne[N],idx;
/*助记：
h[]用来存同起点最后一次出现的下标;
(初始为-1,表示空)
e[]具体出现的是哪个数;ne[]上一次出现的位置;
idx下标分配器,创建新的结点
*/
void input(int x){
    int k=(x%N+N)%N;
    /*这是他映射在小区间上的数
      这里尤其要注意，这里是为了保证他是正的
      A%B,c++中正负号由A决定，且x的最值比N大*/
    e[idx]=x,ne[idx]=h[k],h[k]=idx++;
}
bool find(int x){//遍历这个槽（当前小区间的数链表）
    int k=(x%N+N)%N;
    //不断去找它之前出现的位置，直到-1
    for(int i=h[k];i!=-1;i=ne[i]){
        if(e[i]==x){
            return 1;
        }
    }
    return 0;
}
int main(){
    memset(h,-1,sizeof h);
    int n;scanf("%d",&n);
    while(n--){
        char op[2];//用字符串规避一些空白符
        int x;
        scanf("%s%d",op,&x);//记住这个写法,注意op是首地址
        if(*op=='I'){//*op间接访问，解第一个字符
            input(x);
        }else{
            if(find(x)){
                puts("Yes");
            }else{
                puts("No");
            }
        }
    }
    return 0;
}
```
## 字符串哈希
```
如果涉及到子串的哈希stl,在数量比较大的时候，内存是很容易爆的。
所以这时需要：使用：
    先将字串=>字符串前缀哈希法,先映射成数字=>在对数字map,u_map
    (此时stl的key是数字，但实际映射的字符串)
    
一般情况下，第一个模板哈希完完全全够用了,尤其是需要额外记录
但是如果被卡冲突，也只能用双哈希了，判断时要判断两个,
    如果要额外记录时，map<pii,int>,将映射的两个哈希值都存入。
```
```
给定一个长度为 n 的字符串，再给定 m 个询问，
每个询问包含四个整数 l1,r1,l2,r2，
请你判断 [l1,r1] 和 [l2,r2] 这两个区间所包含的字符串子串是否完全相同。
(字符串中只包含大小写英文字母和数字。)
```
### stl 暴力（会超时）
```c++
s.substr(pos,len);//从字符串下标为pos开始数len个截取
```
## 字符串前缀哈希法
**涉及到子串都可以试试**
**注意：这里string s输入时就不用加1了**
**作用：**

* 能用一个数字表示一个字符串
* h[i]表示字符串[1~i]（这样可以表示出任意字串）


**下面这种写法是最常用的，自然溢出哈希（ull）,p=131或13331**
```cpp
单哈希
/*非常妙的一种算法
    这个算法大多情况下不会发生冲突，不用像之前一样特殊处理冲突
    基本可以当做一个数字代表了一个字符串（但也是哈希的一种），
        他直接用计算机的运算来取模，只保留那几位，超过最高位丢弃
        这里采用前缀和的，所以最好从1开始
*/
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int N=1e5+10;
//这里强调一下，左边是高位
//若采用右边是高位的，运用前缀和运算是，（P进制下）后面是0，很不方便
string s;
typedef unsigned long long ull;//简写,用2^64来取模
const int P=131;//P进制或者13331,百分之99是不会有冲突的
ull h[N],p[N];//为了后续方便处理进制
void init(){
    s=' '+s;//既然都前缀和，要尽量从1开始
    p[0]=1;
    for(int i=1;s[i];i++){
    //俗称：前缀哈希法
        h[i]=h[i-1]*P+s[i];
        p[i]=P*p[i-1];
    }
}
ull get(int l,int r){//一定注意l-1
    return h[r]-h[l-1]*p[r-l+1];//对齐完，在前缀和
    //ull不会出现负数
}
int main(){
    cin>>n>>m>>s;
    //初始化
    init();
    while(m--){
        int l1,r1,l2,r2;
        scanf("%d%d%d%d",&l1,&r1,&l2,&r2);
        if(get(l1,r1)==get(l2,r2))  puts("Yes");
        else                        puts("No");
    }
    return 0;
}
```
> 要么统一有负数要么统一没有负数
>
> **统一用ull或者ll,这样get就不用特意取正数了**

![字符串哈希.jpg](https://cdn.acwing.com/media/article/image/2023/09/03/246003_468cfecc4a-字符串哈希.jpg) 


----------


### 双哈希模板
**对字符串哈希两次 （模数进制数均不同） 产生两个哈希值，比较时就可以比较两元组，更不容易冲突**
如果这个都过不了，也没必要继续了
```c++
tring s;
typedef unsigned long long ull;
struct HASH
{
    ull P,mod,h[N],p[N];
    //P=131，13331
    //余数1e9+7,1e9+9,998244353，19260817，ULONG_LONG_MAX
    void init(ull p_in,ull mod_in,string s)
    {//P级数，模数，字符串
        //前缀哈希法，所以从0开始
        P=p_in;mod=mod_in;
        p[0]=1;
        s=' '+s;
        for(int i=1;i<s.size();i++){    
            p[i]=p[i-1]*P%mod;//爆不了
            h[i]=h[i-1]*P%mod+s[i]%mod;
        }
         
    }
    ull get(int l,int r){
        return (h[r]-h[l-1]*p[r-l+1]%mod+mod)%mod;
        //注意了：这里取正数，一定一定要注意
    }
 }S1,S2;
```
```c++
匹配时用
if(S1.get(l1,r1)==S1.get(l2,r2)&&S2.get(l1,r1)==S2.get(l2,r2)) 
     puts("Yes");
else puts("No");
```
**动态求连续区间和**
```
题意：1.能修改某个数2.求区间和
```
## 树状数组

![树状数组1.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_4e12b1e72c-树状数组1.jpg) 
![树状数组2.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_55e8fa0f2c-树状数组2.jpg) 
```c++
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int maxn=100000;
int a[maxn],tr[maxn];
//其实是从1开始存的

//tr[x]中的一共有几个a[x,x-1,……,x-lowbit+1]
int lowbit(int x){
   return (x&-x); 
}
//修改操作
void add(int x,int y){
    //不断的找父节点
    for(int i=x;i<=n;i+=lowbit(i)){
        tr[i]+=y;
    }
}
//查询前缀和
int sum(int x){
    int res=0;
    for(int i=x;i;i-=lowbit(i)){
        res+=tr[i];
    }
    return res;
}
int main(){
    
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        add(i,a[i]);//类似二维差分
    }
    while(m--){
        int k,x,y;
        cin>>k>>x>>y;
        if(k){
            add(x,y);
        }else{
            cout<<sum(y)-sum(x-1)<<endl;//前缀和思想
        }
    }
    
    return 0;
}
```
## 线段树

**学习**
 ![1.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_1c2d594de4-1.jpg) 
![2.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_20d5b42de4-2.jpg) 
![3.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_2726c1fae4-3.jpg) 
![4.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_15671f242c-4.jpg) 
![5.jpg](https://cdn.acwing.com/media/article/image/2023/04/27/246003_30f6dbb5e4-5.jpg) 

![线段树1.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_303f02432c-线段树1.jpg) 
![线段数2.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_35ac95c02c-线段数2.jpg) 

```c++
//自己写一遍发现真的真的太难写了
/*
我还是喜欢用树状数组，越长的代码越容易出错

这里感觉y总讲得太过省略，
听了一遍感觉数组的下标表示那一层都没搞清楚；
            为什么开4N也没懂
这里我建议看《算法竞赛》上册————线段数，细节讲得比较清楚
*/
/*
（这里不需要lazy—tag标记）（但感觉还是不什么好写）

线段树：（分治+二叉树）
（这里用结构体写，其实用一个数组也能写，但比较容易乱）
大概的思路是：
    将数组的元素（也是一个区间），两两合成一个新的区间，知道合成一个
    （这个与树状数组不同的是，覆盖了所有的区间，
      而树状数组(前缀和)将一些冗余区间给去掉，为了更快更方便的求和，因此丢失了部分功能）

父节点的左儿子为i<<1    i*2
        右儿子为i<<1|1  i*2+1
      
四个核心函数：1.区间（两儿子）合并
              2.建树
              3.查询区间和
              4.修改某个数
              
然后这里的下标是从上到下一层一层（左到右）标记
                （好好看一下图4.12，及上面标的序号）
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
int a[N];
//线段树
struct Node{//每个节点
    int l,r;
    int sum;
}tr[4*N];//看图4.12和第三张图
//1.区间合并（左右儿子合并）
void push_up(int u){//u是当前节点下标
//这里是分治后，找到儿子后一步步合并
    tr[u].sum=tr[u<<1].sum+tr[u<<1|1].sum;
    //           u*2          u*2+1
}
//2.建树
void build(int u,int l,int r){//l表示左边界，r表示有边界
    //注意这里与线段树不太一样，线段树用加入数维护比较方便
    //这里先找到叶子节点（只有一个元素），向上合并比较方便
    if(l==r){
        tr[u]={l,r,a[l]};
        return;
    }else{
        tr[u]={l,r};//别忘了,这里c++11才行
        
        //分两半(这里很像归并的过程),同时得到左右儿子的值
        int mid=(l+r)>>1;//想想问什么要加1
        build(u<<1,l,mid),build(u<<1|1,mid+1,r);
        
        //合并
        push_up(u);
    }
}
//3.查询区间和(这里建议画图)
int query(int u,int l,int r){//l和r分别表示区间的边界
    //找能完全覆盖的区间，相加，就是区间和（从上到下）
    if(l<=tr[u].l&&tr[u].r<=r){
        return tr[u].sum;//判断这个节点是否被这个区间完全覆盖
    }else{
        int res=0;
        //用中点来分,左右都找这样就不会漏了
        int mid=(tr[u].l+tr[u].r)>>1;
            //这里不好分,需要注意下(主要出现的问题在边界上)
        if(l<=mid){//往左儿子找
            res+=query(u<<1,l,r);
        }
        if(r>=mid+1){//往右儿子找
            res+=query(u<<1|1,l,r);
        }
        return res;
    }
}
//4.修改某个值(有这个元素的整个分支都要修改)
void modify(int u,int x,int v){
    if(tr[u].l==tr[u].r){
        tr[u].sum+=v;
        return;
    }else{
        int mid=(tr[u].l+tr[u].r)>>1;
        //看x在那个部分，同时修改哪个部分
        if(mid>=x){//在左边，找左儿子
            modify(u<<1,x,v);
        }else{
            modify(u<<1|1,x,v);
        }
        //修改后的合并
        push_up(u);
    }
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        cin>>a[i];
    }
    build(1,1,n);
    while(m--){
        int k,a,b;
        cin>>k>>a>>b;
        if(k){
            modify(1,a,b);
        }else{
            cout<<query(1,a,b)<<endl;
        }
    }
    
    return 0;
}

```
# 搜索与图论

## 全排序
![dfs.jpg](https://cdn.acwing.com/media/article/image/2023/06/28/246003_ddaba97a15-dfs.jpg) 
###有个空上有多个选择的dfs  
```c++
//初学者建议一定要手动模拟一次
#include<bits/stdc++.h>
using namespace std;
int a[20],n;
bool had[20];//表示用过没有
void dfs(int x){//（递归层数）表示选到第几个数
    if(x>=n){//结束条件，选满了
        for(int i=0;i<n;i++){
            cout<<a[i]<<" ";
        }puts("");
    }
    for(int i=1;i<=n;i++){
        if(!had[i]){//没被用过
            a[x]=i; //这个位置上是i
            had[i]=1;
            dfs(x+1);//看下一个位置
            //回溯后回复现场，将这个位置又清空了
            had[i]=0;//a就不用管了会自动覆盖
        }
    }
}
int main(){
    cin>>n;
    dfs(0);
    return 0;
}
```

### stl next_permutation的经典用法
```c++
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n;cin>>n;
    vector<int> a;
    for(int i=1;i<=n;i++){
        a.push_back(i);
    }
    do{
        for(auto x:a){//c++11中的特性，x表示的就是a[i]
            cout<<x<<" ";
        }
        puts("");
    }while(next_permutation(a.begin(),a.end()));
    //自动进行全排列
    return 0;
}
```
## n-皇后问题
![n皇后问题.jpg](https://cdn.acwing.com/media/article/image/2023/06/28/246003_cd0e61fe15-n皇后问题.jpg) 
### dfs（顺序：一格一格）（选与不选的模板）
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=30;
int n;
char g[N][N];//全局变量初始为'\0'
bool row[N],col[N],dg[N],udg[N];
//分别为行，列，对角线，反对角线是否有皇后
void dfs(int x,int y,int s){//顺序：一格一格
    //到第x行第y列，一共选了s个
    if(y>n){//换行
        x++,y=1;
    }
    if(x>n){//结束条件
        if(s==n){//输出条件
            for(int i=1;i<=n;i++){
                puts(g[i]+1);//利用字符数组的输出特性
            }
            puts("");
        }
        return;
    }
    if(!row[x]&&!col[y]&&!dg[x+y]&&!udg[x-y+n]){//选上
        g[x][y]='Q';
        row[x]=col[y]=dg[x+y]=udg[x-y+n]=1;
        dfs(x,y+1,s+1);
        //恢复现场
        g[x][y]='.';
        row[x]=col[y]=dg[x+y]=udg[x-y+n]=0;
    }
    dfs(x,y+1,s);
}
int main(){
    cin>>n;
    //初始化
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            g[i][j]='.';
        }
    }
    dfs(1,1,0);
    return 0;
}
```
### 优化过后：dfs（顺序：第x行）（每个位置上有多个可能的dfs）
```c++
//这里输出采用记录输出
#include<bits/stdc++.h>
using namespace std;
const int N=30;
int n;
int have[N];//h[i]=x，表示皇后在第i行的第x列上
bool col[N],dg[N],udg[N];
//分别看列，正对角线，反对角线有没有皇后

void dfs(int x){//第x行
//这个方法主要体现在剪枝
    if(x>n){//结束条件，同时输出
        for(int i=1;i<=n;i++){
            for(int j=1;j<=n;j++){
                if(have[i]==j){
                    cout<<'Q';
                }else{
                    cout<<'.';
                }
            }
            puts("");
        }
        puts("");
    }
    for(int j=1;j<=n;j++){
        if(col[j]||dg[x+j]||udg[x-j+n]){
            continue;
        }//有皇后
        have[x]=j;
        col[j]=dg[x+j]=udg[x-j+n]=1;
        dfs(x+1);
        //恢复
        col[j]=dg[x+j]=udg[x-j+n]=0;
    }
}
int main(){
    cin>>n;
    dfs(1);
    return 0;
}
```
## bfs 宽搜
**作用：搜最短路（一层一层搜），一般用于边权都为1的时候（步数）**
**宽搜**
给定一个 $n \times m$ 的二维整数数组，用来表示一个迷宫，数组中只包含 $0$ 或 $1$，其中 $0$ 表示可以走的路，$1$ 表示不可通过的墙壁。

最初，有一个人位于左上角 $(1, 1)$ 处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 $(n, m)$ 处，至少需要移动多少次。

数据保证 $(1, 1)$ 处和 $(n, m)$ 处的数字为 $0$，且一定至少存在一条通路。
```c++
/*
模板：
queue<类型> q;
q.push(初始位置);
while(!q.empty()){
    <类型> t=q.front();
    q.pop();//该元素弹出
    for(所有可拓展的情况){
        if(不合法){//这里还要判断是否走过
            continue;
        }
        q.push(合法)；//入队
     	//一般在标记走过了
    }
}
一般还需配合ans[x][y]来记录首次到达的状态
*/
#include<bits/stdc++.h>
using namespace std;
typedef pair<int,int > pii;//用这个来存坐标
int ans[105][105];//初始化为-1，表示没走过
bool a[105][105];//原数组
int n,m;
//可移动的方向：
int mx[4]={0,1,0,-1};
int my[4]={1,0,-1,0};

int main(){
    
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            cin>>a[i][j];
        }
    }
    //初始化:
    
    memset(ans,-1,sizeof(ans));
    ans[1][1]=0;
    queue<pii> q;
    q.push({1,1});
    while(!q.empty()){
        auto t=q.front();
        int tx=t.first,ty=t.second;
        // cout<<"tx="<<tx<<" "<<"ty="<<ty<<endl;
        q.pop();
        for(int i=0;i<4;i++){
            int x=mx[i]+tx,y=my[i]+ty;
            if(x<=0||x>n||y<=0||y>m||ans[x][y]!=-1||a[x][y]){
                continue;
            }
            ans[x][y]=ans[tx][ty]+1;
            q.push({x,y});
            // cout<<x<<"  "<<y<<" "<<ans[x][y]<<";";
        }
        // cout<<endl;
    }
    cout<<ans[n][m];
    return  0;
}
```
### ==bfs模板==

> **建议直接上第3种模板**:可以避免想很多问题
>
> 
>
> 有个小细节，判断是否搜过还是要注意一下的：
>
> 前两种一般用再权值为0或者1的时候，第一种如果后续涉及更新答案也不太适合
>
> 1. 一般的模板
>
>    场景：能确定第一次拓展到的时候就是最小的时候
>
> ```c++
> while(!q.empty()){
>     <类型> t=q.front();
>     q.pop();//该元素弹出
>     for(所有可拓展的情况){
>         if(不合法||走过了){
>             continue;
>         }
>         q.push(合法)；//入队
>      	标记一下走过了;
>         (能过还有距离的化在这更新)
>          
>     }
> }
> ```
>
> 2. 涉及更新的（像什么最短路）(这个模板可以跳过，很多多用不了)
>
> ```c++
> while(!q.empty()){
>     <类型> t=q.front();
>     q.pop();//该元素弹出
>     if(走过了) continue;
>     标记一下走过了
>     for(所有可拓展的情况){
>         if(不合法||走过了){//小优化：这里也能标记走过了
>             continue;
>         }
>         q.push(合法);//入队
>         在这更新距离
>     }
>     //如果for循环中需要用到标记数组，那么标记可以放这里
> }
> ```
>
> 3.  **更具普适性的模板**
>
>    （本质就是`spfa`求最短路算法）(**发生更新的点，还需要再入队**)
>
>    - 场景：**尤其是那些权值不是1或者0时**，很不好保证二段性和单调性，就是有时候后面才走过的值反倒会更好
>
>    - 做法：**就是将那些发生更新的入队**，同时可以整个小优化：就是队列中不出现的重复的点（没有这个优化，也没事）
>
>    > 标记可以换成是否在队列中，如果在队列中就没必要再入队了
>    >      反正还在队列中用的值已经更新过了，后续会重复用一个值搜两遍
>
>    - 区别：不看是否已经搜过
>
>      （声明：这里标记搜过的，其实就是第一次搜的时候，这种就是要避免后面还会出现更小的）
>
>    ```c++
>    bool has[];//现在这个不是标记是否搜过，而是表示是否在队列中
>    T ans/dist[];//记录权值(一般要初始较大化)
>                                                                                                 
>    初始化起点和其他点
>    while(!q.empty()){
>        <类型> t=q.front();
>        q.pop();//该元素弹出
>        has[这个点]=false;
>        for(所有可拓展的情况){
>            if(不合法){
>                continue;
>            }
>            if(拓展情况更好){//更新后的值<ans[][]
>    			更新一下值
>                 if(不在队列中){
>    				q.push(合法);//入队
>                     has[这个点]=true;
>            	}
>            }
>                                                                                                 
>        }
>    }
>    ```
>

#### ==常犯错误==

1. 测试样例最好测试一下回型的路线

2. ==注意起点就是答案的情况==

   >  最好就是在刚要搜的时候判断一下答案





### 经典例题：八数码（有时间再来看看）

**(学习状态的表示)用字符串来表示状态，以及一维和二维的互相转换**
![八数码1.jpg](https://cdn.acwing.com/media/article/image/2023/06/28/246003_73179cb615-八数码1.jpg) 

![八数码2.jpg](https://cdn.acwing.com/media/article/image/2023/06/28/246003_a51646d215-八数码2.jpg) 



```
题目：
在一个3*3的网格中，将1 2 3
                     x 4 6
                     7 5 8
x能够上下左右交换，变成123 456 78x 的形式,求最小交换步数
```
```c++
/*
很有启发的一题：
    （状态不止可以用{x,y}表示，）
    1.还可以用一个字符串来表示整个图的状态
    2.然后用一个哈希表来记录这个状态的距离
     （key->value,用一个关键字可以是任意类型，得到一个value）
    bfs在将这个字符串，转成二维图的思想

*/
#include<bits/stdc++.h>
using namespace std;
int bfs(string s){
    //初始化
    int dx[4]={-1,0,0,1};
    int dy[4]={0,-1,1,0};
    //移动向量
    string end="12345678x";//结束状态
    unordered_map<string,int> d;
    //记录转移过来的距离，就是之前那个dist数组
    queue<string> q;//注意一下类型
    q.push(s);
    d[s]=0;//这是开始的第一步
    
    //正式开始搜
    while(!q.empty()){
        auto t=q.front();
        q.pop();//呜呜，千万别忘了
        if(t==end){
            return d[end];
        }
        // cout<<t<<endl;
        int k=t.find('x');//找到'x'在哪里
        //转为一维坐标
        int x=k/3,y=k%3;//强调一下这里从0,0开始
        //这个一定要会，一维转二维的基本操作
        for(int i=0;i<4;i++){
            string tmp=t;//多创建这个是为了避免更新
            int tx=x+dx[i],ty=y+dy[i];
            if(tx<0||tx>=3||ty<0||ty>=3){
                continue;
            }
            swap(tmp[tx*3+ty],tmp[k]);//移动这个位置
            //转为一维
            //注意看这里写的顺序,要先移动
            if(d.count(tmp)){//走过了(被记录了)
               //等价于d.find(t)!=d.end();
               continue; 
            }
            d[tmp]=d[t]+1;
            q.push(tmp);
        }
    }
    return -1;//没走到
}
int main(){
    string start;
    for(int i=0;i<9;i++){
        char a;cin>>a;
        start+=a;
    }
    cout<<bfs(start);
    return 0;
}
```

![图的基础.jpg](https://cdn.acwing.com/media/article/image/2023/06/29/246003_851d9c4816-图的基础.jpg) 
```
补充：有向图还有一种比较专精的存储方式：用结构体存
      (缺点：无法快速查边)
      只用在特定的算法，bellman_ford，kruskal
```
## 树的dfs
**树的重心**
```c++
重心定义：重心是指树中的一个结点，
          如果将这个点删除后，剩余各个连通块中 点数的最大值最小

n个结点，用n-1条变连接起来称为树，找树的重心，输出连通块中 点数的最大值
```
![树的重心.jpg](https://cdn.acwing.com/media/article/image/2023/06/29/246003_e25bfb4016-树的重心.jpg) 

 ![](https://cdn.acwing.com/media/article/image/2020/05/22/652_ab4f9f7c9b-1.png) 
### 树的dfs模板
```c++
//图中的边基本就是用邻接表存(不懂的可以看看下面对邻接表的注释)
bool st[N];
void dfs(int u){//搜以u为根的子树
    st[u]=1;//先标记，避免下次搜到
    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];//终点
        if(!st[j]){//没被搜过
            dfs(j);
        }
    }
}
```
```c
#include<bits/stdc++.h>
using namespace std;
int n;
//邻接表(这里其实就是模拟散列表的拉链法)
const int N=1e5+10,M=2*N;//点数，和边数
int h[N],e[M],ne[M],idx;
void add(int x,int y){
    e[idx]=y,ne[idx]=h[x],h[x]=idx++;
    //指向它的上一次出现
}
/*邻接表：就是n链表，这里换一种更好理解的方法
    首先这里的边就是链表结点（占据一个下标）
    （强调一下这里的每条边都是有向边）
    idx下标分配器
    h[x]表示以x为起点的最新的一条边
        初始为-1，表示没有这条边
    e[i]表示这条边的终点
    ne[i]指向上一次出现以x为起点的下标,值为-1表示空
遍历时:
    只需从最新的一条边h[x]，
    然后一直走上一次，直到-1为止
*/
//连通块：就是点的集合，然后点间能互相到达

//树的深搜
bool st[N];//是否已经搜过
//有st后，无论图长啥样，形状都是【以搜的结点为根】的树
int ans=N;//计录最小的连通块的点数，最坏的情况就是所有的点数
int dfs(int u){//这个函数的返回值:是【这棵子数】的点数
//还有个功能:确定以u为重心的最大连通块的结点数（不断对ans进行迭代）
                //好好理解什么叫这颗子树
    st[u]=1;//要在这标记已经搜过了
    int sum=1;//先算上u这个点,要算这棵子树上所有点数
    int maxs=0;//把这个点删掉后，联通块的'点的'最大值(max_size)
    for(int i=h[u];i!=-1;i=ne[i]){
    //不断遍历以x为起点的边
        int j=e[i];//终点
        if(!st[j]){//没有遍历过
            int s=dfs(j);//以j为根节点的这颗
            maxs=max(maxs,s);
            sum+=s;//加上以‘这儿子为根的子树’的点数
        }
    }
    maxs=max(maxs,n-sum);
    //这里别忘记u上面可能还有一个连通块
    ans=min(ans,maxs);//有了u这个maxs，迭代
    return sum;
}
int main(){
    //初始化
    memset(h,-1,sizeof(h));
    cin>>n;
    for(int i=0;i<n-1;i++){
        int a,b;cin>>a>>b;
        add(a,b);add(b,a);
        //无向边是特殊的有向边
    }
    dfs(1);//从哪个点开始，都无所谓，都可以变为树
    cout<<ans;
    return 0;
}
```
## 图的bfs
![树的bfs.jpg](https://cdn.acwing.com/media/article/image/2023/06/29/246003_2401db5216-树的bfs.jpg) 
**从1->n号点的距离**
```c++
//边权都为1，采用bfs
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10,M=1e5+10;
int n,m;
//邻接表(每一个结点是边)
int h[N],e[M],ne[M],idx;//详细的说明看树的重心那里
void add(int x,int y){//不断去存以x为起点的边的上一次出现
    ne[idx]=h[x],e[idx]=y,h[x]=idx++;
}
//stl版
/*
int bfs(){
    int d[N];//从1到这一步的距离
    memset(d,-1,sizeof d);//-1表示到不了
    queue<int> q;//存能到的点
    q.push(1);
    d[1]=0;
    while(!q.empty()){
        int t=q.front();
        if(t==n){
            return d[t];
        }
        q.pop();
        for(int i=h[t];i!=-1;i=ne[i]){//枚举以t为起点的每条边
            int j=e[i];//其实就是b
            if(d[j]==-1){
                q.push(j);
                d[j]=d[t]+1;
            }
        }
    }
    return -1;
}
*/
//数组模拟版
int bfs(){
    int d[N];
    memset(d,-1,sizeof d);
    //队列
    int hh=0,tt=-1;
    int q[N];
    q[++tt]=1;
    d[1]=0;
    while(!(hh>tt)){
        int t=q[hh];
        if(t==n){
            return d[t];
        }
        hh++;
        for(int i=h[t];i!=-1;i=ne[i]){
            int j=e[i];
            if(d[j]==-1){
                //入队
                q[++tt]=j;
                d[j]=d[t]+1;
            }
        }
    }
    return -1;
}
int main(){
    //邻接表中h别忘记初始为-1
    memset(h,-1,sizeof h);
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int a,b;cin>>a>>b;
        add(a,b);
    }
    cout<<bfs();
    return 0;
}
```
## 有向图的拓扑排序
**在解决树的问题时，千万别忘记度数这个概念，在解决例如叶子结点很好用**
```
若一个由图中'所有点'构成的序列 A 满足：
    对于图中的每条边 (x,y)，x 在 A 中都出现在 y 之前，
    则称 A 是该图的一个拓扑序列。
输出拓扑序列
```
![拓扑排序.jpg](https://cdn.acwing.com/media/article/image/2023/08/13/246003_7bdc022039-拓扑排序.jpg) 
```c++
//这里强调一下队列中存的是入度为0的点，只能做起点
//入度就是做终点次数
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n,m;
int d[N];//只记录入度
//邻接表
int h[N],e[N],ne[N],idx;
void add(int x,int y){//不断去指向上一次出现的边
    ne[idx]=h[x],e[idx]=y,h[x]=idx++;   
}
//模拟队列
//这里用模拟队列才能方便最后的输出,因为队列中都是假删
//如果用stl的话，要加上一个vector数组来存数据
int hh=0,tt=-1,q[N];//只存入度为0
bool topsort(){//用对入度为0的bfs来找
    
    for(int i=1;i<=n;i++){//枚举所有的点
        if(!d[i]){//!(d[i]!=0) => d[i]==0
            q[++tt]=i;//注意，这里模板++的位置
        }
    }
    while(!(hh>tt)){//队列非空
        int t=q[hh++];//记录下对头，顺便出队
        //删去以这个点为起点的边
        for(int i=h[t];i!=-1;i=ne[i]){
            int j=e[i];
            d[j]--;
            if(!d[j]) q[++tt]=j;//入度为0时,入队
                        //不会重复加的，否则入度不会为0
        }
    }
    return tt==n-1;
    //当把所有点都存入队列中时，则满足拓扑排序
}
int main(){
    //邻接表初始化
    memset(h,-1,sizeof h);
    
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int a,b;cin>>a>>b;
        add(a,b);
        d[b]++;
    }
    if(topsort()){
        //入队的顺序就是排序的顺序
        for(int i=0;i<n;i++){
            cout<<q[i]<<" ";
        }
        
    }else puts("-1");
    return 0;
}
```
## 最短路问题



![最短路各个算法使用场景.jpg](https://cdn.acwing.com/media/article/image/2023/05/16/246003_cedc1e80f3-最短路各个算法使用场景.jpg) 

**`Dijkstra`题目**（仅带正权边）

给定一个 n 个点 m 条边的有向图，图中可能存在重边和自环，所有边权均为正值。
请你求出 1 号点到 n 号点的最短距离，如果无法从 1 号点走到 n 号点，则输出 −1。

### Dijkstra求最短路 I(数组存边+暴力找最短边)



![dijkstra1.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_c295f9ab52-dijkstra1.jpg) 
![dijkstra2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_c835d0c852-dijkstra2.jpg) 

```c++
//使用邻接矩阵一定要注意重边,和初始较大化

#pragma GCC optimize(2)
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
int dist[510];//distance 最短路，距离起点的最短距离，需要更新,初始较大化
bool had[510]={0};//看是否已经遍历过,0表示没遍历过
int link[510][510];//记录每个连接的最小边，记录x->y的边长，link[x][y]，初始较大化
int n,m;
int dijkstra(){
    //每一个大循环其实就出一个贪心的结果
    for(int i=0;i<n;i++){
        int m=-1;//找出其中的那个点距离起点最小
        for(int j=1;j<=n;j++){
            if(!had[j]&&(m==-1||dist[m]>dist[j])){
                m=j;//更新最小且没用过的点
            }
        }
        had[m]=1;//这个已经用过了
        for(int j=1;j<=n;j++){//唉，小小注意一下，编号大点是可能到小点
            dist[j]=min(dist[j],dist[m]+link[m][j]);//更新，没有连接的自动过滤(加了个大值)
        }
    }
    if(dist[n]==168430090){//非法的答案
        return -1;
    }
    return dist[n];
}
int main() {
// 	freopen("shuru.txt","r",stdin);

	ios::sync_with_stdio(false);
	cin.tie(0);
	cout.tie(0);
    //初始化
    memset(dist,10,sizeof(dist));//并不是赋值为10//赋值为168430090
    dist[1]=0;//起点1
    memset(link,10,sizeof(link));

    cin>>n>>m;
    while(m--){
        int x,y,z;
        cin>>x>>y>>z;
        link[x][y]=min(link[x][y],z);//由于存在重边
    }
    cout<<dijkstra();
	return 0;
}
```
### Dijkstra求最短路 II(堆+邻接表)

只有将要更新这个点相连边的时候才能确定，是起点到这个点的最短路
![dijkstra2.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_c835d0c852-dijkstra2.jpg) 
![dijkstra3.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_060bfaa652-dijkstra3.jpg) 
![dijkstra4.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_09213a9652-dijkstra4.jpg) 
```c++
/*碎碎念：
我这个算法弯弯绕绕学了挺长时间的，主要是战队要求这个算法，我就提前来学这个算法
但学着就发现这个算法没有那么好学，那时数据结构也没接触过几个，但这个算法很需要数据结构，还有一些是图的知识
一度想放弃这个，以我这水平是真心不好理解
但还是坚持下来，给它硬搞下来，可恶，逢山开路，遇水搭桥,疯狂去学习没接触过的东西
*/
//这个是对朴素dijkstra的优化，整体的思路大体一致，但是有很多的细节不同

#include<iostream>
#include<queue>
#include<vector>//上面这两个使用  调过优先级的  优先队列
#include<utility>//想使用pair类型，类似结构体
#include<cstring>
using namespace std;

typedef pair<int,int> pii;//一对：first,second

int n,m;
const int maxn=1.5e5+10;

/*为什么用链接表呢？
可以看看当前最短边的点，看它连了多少边
*/
//接下来是链表所需的参数
int e[maxn],l[maxn],fx[maxn],cnt;
//这里是邻接表
/*
这里分别对应每条边，从n开始
e表示当前边所表示y也就是终点end；l表示边长length；fx表示上一个起点为x的编号；cnt表示当前所对应的边
*/
int nx[maxn];//nx[i]表示当前起点为x（即为i）  的边所对应的编号，用来赋给fx，需要更新，一开始赋值为-1
//最后nx为起点x最后出现的边(也就是编号)
void add(int x,int y,int z){//链接表的形式
    e[cnt]=y,l[cnt]=z,fx[cnt]=nx[x],nx[x]=cnt,cnt++;
}//用更新每条边

int dist[maxn];//该点所对应的最短边，需要大化
int had[maxn]={0};//该点是否用过

int dijkstra(){
    priority_queue<pii,vector<pii>,greater<pii> > q;//改变优先级的优先队列，主要表现优先级最高一定在队首
//pair是先比first在比second
    q.push({0,1});//前者表示当前点到起点的长度，后者表示当前点
    //为什么这样呢，因为我们要找到最短边,而最短边就在最上方，尽管会有部分冗余的点，但是我们可以标记它是否走过
    while(!q.empty()){//直到全部边都走完
        auto tmp=q.top();//auto自动类型，用不用都没差
        int now=tmp.second;//当前点,x，说具体点x就是起点到y的中转点
        q.pop();//出队
        if(had[now]){//走过了就不走了
            continue;
        }
        had[now]=1;//走过了
        //接下来要更新其相连的点了
        for(int i=nx[now];i!=-1;i=fx[i]){//这里是邻接表，不断的去链接上一条边，直到-1，这样就能找到所有起点为now的边了
            int y=e[i],len=dist[now]+l[i];//起点->y的边长
            if(dist[y]>len){//最短边更新
                dist[y]=len;
                q.push({len,y});//压入
            }
        }

    }
    if(dist[n]>1e9){
        return -1;
    }
    return dist[n];

}
int main(){

    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);

    //初始化
    memset(nx,-1,sizeof(nx));//当前边都在-1，代表不存在这个边
    memset(dist,100,sizeof(dist));//较大化，便于取最小，且不容易溢出
    dist[1]=0;
    cin>>n>>m;
    while(m--){
        int x,y,z;
        cin>>x>>y>>z;
        add(x,y,z);
    }
    cout<<dijkstra();
    return 0;
}
```

### bellman-ford(递推)

(**有边数限制，允许存在负权回路**)(有点像递推)



[853. 有边数限制的最短路 - AcWing题库](https://www.acwing.com/problem/content/855/)

给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，**边权可能为负数**。
请你求出从 $1$ 号点到 $n$ 号点的最多经过 $k$ 条边的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，输出`impossible`。
注意：图中可能**存在负权回路**。     

---



![bellman ford.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_d843ef0b52-bellman-ford.jpg) 

```c++
存在负权边，且有可能为回路，只能经过k条边
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m,k;
struct edge{
    int x,y,z;
}edge[10010];
int dist[510];//最短边
int backup[510];//备份免得重复走
void bellman_ford(){
    memset(dist,100,sizeof(dist));
    dist[1]=0;
    for(int i=0;i<k;i++){
        memcpy(backup,dist,sizeof(backup));//只用上一步做得来更新，免得串联，就是更新后又按更新的走，这样可能走了不止k步
        for(int j=0;j<m;j++){
            int x=edge[j].x,y=edge[j].y,z=edge[j].z;
            dist[y]=min(dist[y],backup[x]+z);//这里需要注意一下，是跟dist[y]比
            // cout<<"x="<<x<<"   y="<<y<<"  dist[y]"<<dist[y]<<endl;
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);

    cin>>n>>m>>k;
    for(int i=0;i<m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        edge[i]={x,y,z};
    }
    bellman_ford();
    // cout<<dist[n]<<endl;
    if(dist[n]>1e8){
        cout<<"impossible";
    }else{
        cout<<dist[n];
    }
    return 0;
}
```

----





**`spfa`算法**：（对上面的优化，只走那些被更新的点）

求有负权边，但是无负权回路的最短路

也可判断是否有负权环

### spfa求最短路(暴力搜索)



题目：给定一个$n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环， **边权可能为负数**。

请你求出 $1$ 号点到 $n$号点的最短距离，如果无法从 $1$ 号点走到 $n$ 号点，则输出 `impossible`。

数据保证**不存在负权回路**。

-----



![spfa算法.jpg](https://cdn.acwing.com/media/article/image/2023/06/30/246003_5d3d69f817-spfa算法.jpg) 

```c++
#include<iostream>
#include<algorithm>
#include<queue>
#include<cstring>
using namespace std;
int n,m;
const int maxn=1e5+10;
//邻接表：
int nx[maxn],fx[maxn],e[maxn],l[maxn],idx=0;
//nx（now——x）记录起点为x的最后一次出现的编号；fx是链接上一次出现的编号(初始化为-1，代表还未出现)；
//e（end）就是y啦；l表示边长；idx就是编号
void add(int x,int y,int z){//录入
    fx[idx]=nx[x];e[idx]=y;l[idx]=z;nx[x]=idx++;
}//注意fx和nx是关键
int dist[maxn];//最短路，初始较大化,dist[1]=0
int had[maxn]={0};//优化一下，队伍内没必要重复加入

void spfa(){
     //初始化
    memset(dist,100,sizeof(dist));
    dist[1]=0;

    queue<int> q;
    q.push(1);
    had[1]=1;//已经在队伍内了
    while(!q.empty()){//没路了就自动停了
        int t=q.front();
        q.pop();
        had[t]=0;//取出后就没有了
        for(int i=nx[t];i!=-1;i=fx[i]){
            int y=e[i],tl=dist[t]+l[i];
            // cout<<y<<" "<<"tl="<<tl;
            if(dist[y]>tl){//更小就更新
                dist[y]=tl;
                // cout<<dist[y]<<endl;
                if(!had[y]){
                    q.push(y);
                    had[y]=1;
                }
            }
        }
    }
}

int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);

    cin>>n>>m;
    memset(nx,-1,sizeof(nx));
    for(int i=0;i<m;i++){//邻接表
        int x,y,z;
        cin>>x>>y>>z;
        add(x,y,z);
    }
    // for(int i=nx[1];i!=-1;i=fx[i]){
    //     cout<<i<<" ";
    // }
    spfa();
    // cout<<dist[n];
    if(dist[n]>1e9){
        cout<<"impossible";
    }else{
        cout<<dist[n];
    }
    return 0;
}
```
### spfa判断负环

```c++
//注意这里环不一定在1这个点上才有，所以每个点都要加入队列
//当到这个点走了超过n边，根据抽屉原理，那么一定有环
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
int n,m;
const int maxn=1e5+10;
int dist[2010];//也不用较大化了，只要找负环
int cnt[maxn];

//邻接表:记录边
int nx[2010];//每个点当前所对应的最新编号,赋为-1,nx[x]
int fx[maxn],e[maxn],l[maxn],idx=0;
//fx表示同为起点x的边上一次出现的位置，e表示y终点，l表示边长
void add(int x,int y,int z){
    e[idx]=y,l[idx]=z,fx[idx]=nx[x],nx[x]=idx++;
}

bool had[2010];//表示有没有在队列中
bool spfa(){
    queue<int> q;//当前所被更新过的x
    //无需重复更新，因为dist为全局变量会跟着更新
    for(int i=1;i<=n;i++){//注意每个点都要加
        q.push(i);
        had[i]=1;
    }
    while(!q.empty()){
        int x=q.front();
        // cout<<x<<"  ";
        q.pop();
        had[x]=0;
        for(int i=nx[x];i!=-1;i=fx[i]){
            int y=e[i],ly=dist[x]+l[i];
            if(ly<dist[y]){//负环被记录，小于0，其他的就没必要了
                dist[y]=ly;
                cnt[y]=cnt[x]+1;//后面的会更大，如果相连前面会被后面更新掉
                //max(cnt[y],cnt[x]+1);
                if(cnt[y]>=n){
                    return 1;
                }
                if(!had[y]){
                    q.push(y);
                    had[y]=1;//无需重复加入
                }
            }
        }
        
    }
    return 0;
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    
    // memset(dist,100,sizeof(dist));
    // dist[1]=0;
    memset(nx,-1,sizeof(nx));
    
    cin>>n>>m;
    for(int i=0;i<m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        add(x,y,z);
    }
    spfa();
    if(spfa()){
        cout<<"Yes";
    }else{
        cout<<"No";
    }
    return 0;
    
}
```

### Floyd求最短路(dp递推)

```
可以具体查询，任意两点的最短路,有负权边也没事
```
[854. Floyd求最短路 - AcWing题库](https://www.acwing.com/problem/content/856/)

给定一个 $n$ 个点 $m$ 条边的有向图，图中可能存在重边和自环，边权可能为负数。

再给定 $k$ 个询问，每个询问包含两个整数 $x$ 和 $y$，表示查询从点 $x$ 到点 $y$ 的最短距离，如果路径不存在，则输出 `impossible`。

数据保证图中不存在负权回路。

``` c++
//注意x->x 距离为0

//这个算法涉及简单的动态规划，我现在暂时没学，只能简单且不严谨的解释，只帮助理解
//这个代码看起来虽然很像暴力枚举，但感觉并不是
//唉，虽然代码非常简单，但说实话我感觉并不好理解(可能是我比较笨吧)
/*1.首先嘚搞明白一点，根据对前面的算法学习:
        你会发现若这条最短路（1->5->9->3->30）经过了多个点，那其中任意两点都是最短路
        (这里应该算是贪心)
*/
/*2.然后将floyd算法简单模拟会发现：
        若任意一条经过多个点的最短路(a->b->c->d->e->f)；
        这个算法一定能够确定走了“相邻的”3个点的最短路（划重点是相邻的）；
        因为这个中间的点一定是从小到大确定的，所以先确定的一定是中间点小的；
        （前->中(小的)->后）
        这个最短边操作完后，其实就能忽略掉中间点；
        不断去循环上述的过程，最终一定能当做只剩两个点。
*/
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;
#define f(i,n) for(int i=1;i<=n;i++)//宏定义，略写，因为涉及到较多的循环
int n,m;
int dist[210][210];//因为要去min，初始较大化，同时有个隐含条件就是x==y时，距离为0
void floyd(){
    f(i,n){//i就是中间点
        f(x,n){
            f(y,n){
                dist[x][y]=min(dist[x][y],dist[x][i]+dist[i][y]);
            }
        }
    }
}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    
    int k;
    cin>>n>>m>>k;
    //初始
    memset(dist,10,sizeof(dist));
    f(i,n){
        dist[i][i]=0;
    }
    f(i,m){
        int x,y,z;
        cin>>x>>y>>z;
        dist[x][y]=min(dist[x][y],z);//有重边
    }
    floyd();
    while(k--){
        int x,y;
        cin>>x>>y;
        if(dist[x][y]>4e6){
            cout<<"impossible\n";
        }else{
            cout<<dist[x][y]<<"\n";
        }
    }
    
    return 0;
}
```











**最小生成树**
给定一个 $n$ 个点 $m$ 条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 $G=(V, E)$，其中 $V$ 表示图中点的集合，$E$ 表示图中边的集合，$n=|V|$，$m=|E|$。

由 $V$ 中的全部 $n$ 个顶点和 $E$ 中 $n-1$ 条边构成的无向连通子图被称为 $G$ 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 $G$ 的最小生成树。


----------

## 最小生成树

两者区别：Prim在稠密图中比Kruskal优，在稀疏图中比Kruskal劣。Prim是以更新过的节点的连边找最小值，Kruskal是直接将边排序。



题目：

给定一个 $n$ 个点 $m$
条边的无向图，图中可能存在重边和自环，边权可能为负数。

求最小生成树的树边权重之和，如果最小生成树不存在则输出 `impossible`。

给定一张边带权的无向图 $G=(V, E)$，其中 $V$ 表示图中点的集合，$E$
表示图中边的集合，$n=|V|$，$m=|E|$。

由 $V$ 中的全部 $n$ 个顶点和 $E$ 中 $n-1$ 条边构成的无向连通子图被称为
$G$ 的一棵生成树，其中边的权值之和最小的生成树被称为无向图 $G$
的最小生成树。



### Prim算法求最小生成树(加点法)

适用于稠密图：

**数据范围：**$1 \le n \le 500$,$1 \le m \le 10^5$,图中涉及边的边权的绝对值均不超过 $10000$。

```c++
//唉，这个算法说实话，我看视频没看懂，最后是模拟这个代码搞懂的
//这个算法与dijkstra算法，很相似，但没必要学堆优化版的，后面有个算法可以替代

//注意是无向图

/*最小生成树就是用n-1个边连接n个点
思路：（贪心，关键是找与集合相连的最短边）
1.创建一个集合用来存点（最小生成树内的点）
2.dist用来存与这个集合相连的边（注意一下在集合内的点之间就不算相连了，had数组标记，同时也是在存点），
(dist[x]表示x点到这个集合的最短距离)
3.重复下述的过程(直到所有的点都在集合内  或是  有个点与集合断开时)：
    a.找到这些边的最短边（需循环所有边），其中相连的点t，记得标记一下——加入集合
    b.用这个点t去更新dist
*/
#pragma GCC optimize(2)
#include<iostream>
#include<cstring>
#include<algorithm>
using namespace std;

int n,m;
int link[510][510];//存每条边，较大化
int dist[510];//把维护与集合相连的边，较大化
bool had[510];//标记点，顺带进集合
int ans=0;
bool prim(){
    //初始化：
    memset(dist,100,sizeof(dist));
    dist[1]=0;
    for(int i=0;i<n;i++){
        int t=-1;
        for(int j=1;j<=n;j++){
            if(!had[j]&&(t==-1||dist[t]>dist[j])){//找最短的边
                t=j;
            }
        }
        if(dist[t]>1e4){
            return 1;
        }
        ans+=dist[t];
        had[t]=1;//标记点
        for(int j=1;j<=n;j++){
            dist[j]=min(dist[j],link[t][j]);
        }

    }
    return 0;

}
int main() {
// 	freopen("shuru.txt","r",stdin);

	ios::sync_with_stdio(false);
	cin.tie(0);cout.tie(0);

	cin>>n>>m;
	memset(link,100,sizeof(link));
	for(int i=0;i<m;i++){
	    int u,v,w;
	    cin>>u>>v>>w;
	    link[u][v]=link[v][u]=min(link[u][v],w);//有重边，同时无向边是特殊的有向边
	}
    if(prim()){
        cout<<"impossible";
    }else{
        cout<<ans;
    }
	return 0;
}
```
### Kruskal算法求最小生成树(加边法)

适用于稀疏图：

数据范围：$1 \le n \le 10^5$,$1 \le m \le 2*10^5$,图中涉及边的边权的绝对值均不超过 $1000$。

```c++
/*
kruskal算法又称加边法，从最小边开始加，边里会有两个点，将这些点加入集合中
一个点可以连多个边，但是边不能是集合内的点
*/


/*
一开始原本想使用存下标记法，想用had数组标记在集合内（就是最小生成树）的点，
但发现根本就行不通，有的集合间并没有联通，这问题需要注意
*/
//这里标记联通的集合需要用到并查集，我这时候还没去学
//尽管并查集代码很短，但设计的无比巧妙
//是通过模拟代码大概理解其中的步骤和方法，应该不是很严谨，但还是硬解释一下
/*并查集
储存：一维数组  p[]
        需注意：数组的标号表示点，取值也表示点
初始化：p[i]=i;  //代表没有点联通，点i->i，就是一个孤零零的点（其实也是个集合，也是一个根节点）
相联操作(集合合并)：p[x]=y;  //先简单理解为x->y，
                   //下面你需要非常注意这个x和y到底表示的是什么？相联的是什么？
寻找集合最前头的点（find）：递归dfs函数，找到p[x]==x,的那个点，就是根节点(根节点就是当前点所在集合中最前面（新）的那个点)
							（这里可以路径压缩优化）
*/
/*先举个例子：（朴素版）（没有路径压缩）
这里的集合是按顺序加入的：
一开始：{5，7，3}
    int x=find(5)=5,int y=find(7)=7（别忘了已经初始化了）
    p[x]=y  p[5]=7，（p[7]=7;）  7变为了这个集合的最新点，find接下来找的就是这个
    p[7]=3;p[3]=3;              此时3变为了最新点，find找这个
然后：在创个集合{1，6，2}；
      p[1]=6;p[6]=2;p[2]=2;     2是最新点
最后：合并集合{7，6}
        find(7)=3,find(6)=2;
        p[3]=2;                 连接集合，2是最新点
*/
/*解释：
    x其实是表示以x为暂时最前头节点的集合；y同理；
    代表x->y，x与y相联，y更新为【合并后两个集合】的根节点（最新点）
    a[旧节点]=新节点；   a[新节点]=新节点；
    //这里着重理解一下
*/

/*
    初始化也可为：-1
    find根节点就是找-1
*/

#pragma optimize(2)
#include<iostream>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=1e5+10,M=2e5+10;
int n,m;
struct Node{
    int x,y,z;
    bool operator<(const Node &other)const{//结构体的重载，便于排序
        return z<other.z;
    }
}node[M];//存边
//并查集
int p[N];
void init(){//并查集初始化
    //第一种
    for(int i=1;i<=n;i++){
        p[i]=i;
    }
    //第二种
    // memset(p,-1,sizeof(p));
}
//find函数你需要仔细看看，这个是有讲究的
////第一种
int find(int x){
    if(p[x]!=x){
        // return find(p[x]);//一开始我写是这个，但是他找到答案会一层一层返回，效率低
								//上面这个就是路径优化
        p[x]=find(p[x]);
    }
    return p[x];
    
}
//第二种
// int find(int x){
//     if(p[x]!=-1){
//         p[x]=find(p[x]);//这里就是路径压缩
//         //返回的同时更新p[x]，将走过的都为同个根节点

//     }else return x;//注意一下返回的是点
    
// }
int cnt=0;//根据前面做的题你会知道，想相联n个点，那他必须为n-1条边
//并查集也是一种相联操作，没操作一次表示连一条边
long long ans=0;
void kruskal(){
    sort(node,node+m);//从小到大排
    for(int i=0;i<m;i++){
        int x=node[i].x,y=node[i].y,z=node[i].z;
        int a=find(x),b=find(y);//找各自集合的最新的（根节点）
        //其中a表示旧的，b表示新节点
        if(a!=b){
            p[a]=b;//集合合并，b成为这个集合的新节点
            cnt++;//连了一条边
            ans+=z;
        }
    }
    if(cnt==n-1){
        cout<<ans;
    }else{
        cout<<"impossible";
    }

}
int main(){
    ios::sync_with_stdio(false);
    cin.tie(0);cout.tie(0);
    cin>>n>>m;
    init();
    for(int i=0;i<m;i++){
        int x,y,z;
        cin>>x>>y>>z;
        node[i]={x,y,z};
    }
    kruskal();
    return 0;
}
```
## 染色法判定二分图

![IMG20230914215411.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_684c680853-IMG20230914215411.jpg) 
```c++
//基本思路：用染色法，对没有染色的进行染色，看染色是否成功
//dfs中要传个颜色
//染色法：只有两个颜色，相邻的颜色要不同
#include<bits/stdc++.h>
using namespace std;
//在强调一遍：无向边是特殊的有向边
const int N=1e5+10,M=2e5+10;//边是两倍
int n,m;
//邻接表存边
int h[N],e[M],ne[M],idx;
//千万注意每个结点表示的是边，所以是M
//  h[x]表示起点的链表头，所以用的是N
void add(int x,int y){
    ne[idx]=h[x],e[idx]=y,h[x]=idx++;
}
void init(){
    memset(h,-1,sizeof h);
}
int color[N];//表示颜色，0未染色
bool dfs(int u,int c){//返回u是否成功染上色c
    //顺便对没有染色的终点，染上色
    color[u]=c;
    //h[u]起点为u的边，最后一次出现的位置。边i
    for(int i=h[u];i!=-1;i=ne[i]){
        int j=e[i];
        if(!color[j]){//若j这个点没染色
            if(!dfs(j,3-c)) return 0;//若失败
                //3-c,当c=1,为2；当c=2，为1
        }else if(color[j]==c) return 0;
                //不能跟相邻的点一样,染色发生冲突
    }
    return 1;
}
int main(){
    scanf("%d%d",&n,&m);
    init();
    while(m--){
        int a,b;
        scanf("%d%d",&a,&b);
        add(a,b),add(b,a);
    }
    bool flag=1;//没倒1，表示成功染色
    for(int i=1;i<=n;i++){
        if(!color[i]){
            if(!dfs(i,1)){
                flag=0;
                break;//破开循环
            }
        } 
    }
    if(flag) puts("Yes");
    else puts("No");
    return 0;
}
```
**二分图的最大匹配**
## 匈牙利算法（后来者居上）
```
有左右两部分点的集合，还有一个左右边的集合，
从边的集合中，找没有公共点，且最多边的情况
```
```
可以再看看这篇题解：
https://www.acwing.com/solution/content/5334/
以及下面的评论
```
![二分图的最大匹配.jpg](https://cdn.acwing.com/media/article/image/2023/07/05/246003_477374ba1b-二分图的最大匹配.jpg) 
```c++
/*
匈牙利算法：
（感觉更适合叫后来者居上算法）
大概的思路：
    给每个的男孩子匹配女孩子(看每条边)
                    （这里只是为了便表示，男女都一样）
    1.如果没有匹配过的女孩子还是孤身一人，那就成功
    2.如果不是，就让女孩的男盆友重新匹配，  
                如果发现还有备胎，那女孩直接绿它
                没有则接着跟他处
                
时间复杂度最坏为O(nm),一般都很快
*/
#include<bits/stdc++.h>
using namespace std;
const int N=510,M=1e5+10;
int n1,n2,m;
//尽管是有向边，但只需对一侧进行匹配，另一侧的不需要(存左到右的就好)
//各种标记操作都是针对右部的
//邻接表（不用怕重边自环）
int h[N],e[M],ne[M],idx;
void init(){
    memset(h,-1,sizeof h);
}
void add(int x,int y){
    e[idx]=y,ne[idx]=h[x],h[x]=idx++;
    //指向上一个同起点的边
}
bool st[N];
/*
功能：判断当前男生，女孩是否已经被匹配
    (如果没有很可能会反复匹配同一个)
为什么要重置？
    那是之前别人追的，你还是能重新追
*/
int match[N];//匹配的男友是谁，方便后面让他再匹配
bool find(int x){
    for(int i=h[x];i!=-1;i=ne[i]){
        int j=e[i];//当前要匹配的女孩
        if(!st[j]){//若没匹配
        //这里其实还能优化，就是将那些女孩不能松动的标记一下
            st[j]=1;//标记已经匹配过
            if(match[j]==0||find(match[j])){
            //没匹配过的直接上或者已经男友的看是否还能再匹配
                match[j]=x;
                return 1;
            }
        }
    }
    return 0;
}
int main(){
    cin>>n1>>n2>>m;
    init();
    while(m--){
        int u,v;cin>>u>>v;
        add(u,v);
        //注：有时uv相同，但他并不是相同的点，（分别是左右部的点）
    }
    int ans=0;
    for(int i=1;i<=n1;i++){//只看左部就行
        memset(st,0,sizeof st);
        if(find(i)) ans++;
    }
    cout<<ans;
    return 0;
}
```
# 数学知识
## 试除法判定质数

```c++
//试除法（其实就是暴力）
// 时间复杂度一定为O(sqrt(n))
//试除法（其实就是暴力）
#include<bits/stdc++.h>
using namespace std;
bool is_prime(int x){
    if(x<2){
        return 0;
    }
    for(int i=2;i<=x/i;i++){
    /*不推荐的判断条件:
    1.i<=pos(n,0.5),每次都会算一遍
    2.i*i<=n,可能会爆
    */
        if(x%i==0) return 0;
    }
    return 1;
}
int main(){
    int n;cin>>n;
    while(n--){
        int a;cin>>a;
        if(is_prime(a)) puts("Yes");
        else            puts("No");
    }
    return 0;
}
```
## 分解质因数
```
题：小到大的顺序输出其分解质因数后，每个质因数的底数和指数，每个底数和指数占一行。
```
 ![](https://sat02pap005files.storage.live.com/y4m7FuvQHqtdFmlwefcvjxqyBcukeYZL_YmG-EsrN_-n9-RqrvFDKVbR-k4Dh-EyGtbt9tjysQne_9ZJsUagnnzQGc2v_lnTVILHrXeh0rwiPTxy2drnWZKGXtopMHt6qRmITMY2OYMXWjFUhtsyfTHpOGrPFiP6lWNnAqwF55sm2-r7_kE6Zz0VkWM1suZJYbf?encodeFailures=1&width=2404&height=3324) 

```c++
#include<bits/stdc++.h>
using namespace std;
void divide(int x){
    for(int i=2;i<=x/i;i++){//最后筛出来是质数（这里看笔记）
                            //就是i的因子同时也会被筛出来
        if(x%i==0){//这一步不是多余的，这样才能保证是因数
            int cnt=0;
            while(x%i==0){
                x/=i;
                cnt++;
            }
            cout<<i<<" "<<cnt<<endl;
        }
    }
    if(x>1) cout<<x<<" "<<1<<endl;
    //性质x最多只包含一个大于sqrt(x)的质因数,因为根号相乘>x
    cout<<endl;
}
int main(){
    int n;cin>>n;
    while(n--){
        int a;cin>>a;
        divide(a);
    }
    return 0;
}
```
> **先筛$1\dots x/i$，不要忘记本身就是质数的情况**

## 筛质数

![素数筛.jpg](https://cdn.acwing.com/media/article/image/2023/07/07/246003_598f609c1c-素数筛.jpg) 
### 埃氏筛
```c++
/*
倍数筛（我自称的）
    若没被筛过的为质数
    筛出所有倍数
优化：只筛出质数的倍数即可
这样又被称为埃氏筛
时间复杂度为：O(nloglog n)
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
bool st[N];
int cnt,prime[N];//记录出现过的质数
void get_prime(int n){//获得从2到n的质数
    for(int i=2;i<=n;i++){
        if(st[i]) continue;//不是质数的跳过
        prime[cnt++]=i;//记录下素数
        for(int j=i+i;j<=n;j+=i){//质数的倍数
            st[j]=1;
        }
    }
    
}
int main(){
    int n;cin>>n;
    get_prime(n);
    cout<<cnt;
    return 0;
}
```
### 线性筛（欧拉筛）（这个记下来就行）
```c++
/*
线性筛：
    用最小质因数来筛合数
好处：时间复杂度低，且能得到最小质因数
时间复杂度一定为O(n)
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e6+10;
bool st[N];
int cnt,prime[N];
void get_prime(int n){
    for(int i=2;i<=n;i++){
        if(!st[i]){//没筛到就是质数
            prime[cnt++]=i;
        }
        for(int j=0;prime[j]<=n/i;j++){
        //无需在j<=cnt,若是质数，最后会自动break，不是则提早停
            //prime[j]就是i*prime[j]的最小质因数
            st[i*prime[j]]=1;
            if(i%prime[j]==0) break;
            //上面这一句是为保证prime[j]是最小质因数（具体看笔记）
        }
    }
}
int main(){
    int n;cin>>n;
    get_prime(n);
    cout<<cnt;
    return 0;
}
```
## 试除法求约数
```c++
//由于是一对对出现，只需枚举小的那一部分，注意根号n是因子的情况
#include<bits/stdc++.h>
using namespace std;
vector<int> get_divisors(int n){
    vector<int> ans;
    for(int i=1;i<=n/i;i++){
        if(n%i==0){
            ans.push_back(i);
            if(i!=n/i) ans.push_back(n/i);
            //特判：避免出现平方的情况
        }
    }
    sort(ans.begin(),ans.end());
    return ans;
}
int main(){
    int n; cin>>n;
    while(n--){
        int a;cin>>a;
        vector<int> ans=get_divisors(a);
        for(auto x:ans){
            cout<<x<<" ";
        }
        puts("");
    }
    return 0;
}
```
## 约数个数

约数，又称因数。a称为b的倍数，b称为a的约数。约数是包括1的

**stl**
```c++
//先进行质因数分解，剩下的就是约数之和的数学公式
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int  main(){
    int n;cin>>n;
    unordered_map<int,int> primes;
    //采用哈希表来记录这个质数的出现次数
    while(n--){
        int x;cin>>x;
        //质因数分解
        for(int i=2;i<=x/i;i++){
            while(x%i==0){
                primes[i]++;
                x/=i;
            }
        }
        if(x>1) primes[x]++;
        //根据性质：最多只有一个质因子会大于sqrt(x)
    }
    long long ans=1;
    for(auto p:primes){//遍历整个哈希表
    //哈希表其实是用pair类型来存的
        ans=ans*(p.second+1)%mod;
        //*和%是同优先级，结合性是从左到右
    }
    cout<<ans;
    return 0;
}
```
![求所有约数.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_d283643653-求所有约数.jpg) 
**数组模拟**
```c++
//数组模拟哈希表（复习一下，不推荐这个写法）
#include<bits/stdc++.h>
using namespace std;
const int mod=1e9+7;
int n;
//哈希表：使用开放寻值法
const int N=6421;
int h[N];
/*
int的数据范围大约为2^32,也就是说最多质因数个数就是32
32*100的2倍的第一个质数是6421，不是质数应该也没事
*/
int cnt[N];//记录这个数出现个数
void init(){
    memset(h,-1,sizeof(h));//都是正整数
}
int find(int x){//每一个下标都记录一个数
    int k=x%N;//(x%N+N)%N;都是正整数
    while(h[k]!=-1&&h[k]!=x){
        k++;
        if(k>=N) k=0;//回到0
    }
    return k;
}
int  main(){
    init();
    cin>>n;
    while(n--){
        int x;cin>>x;
        //质因数分解
        for(int i=2;i<=x/i;i++){
            while(x%i==0){
                int k=find(i);
                h[k]=i;
                cnt[k]++;
                x/=i;
                // cout<<k<<" "<<cnt[k]<<endl;
            }
        }
        if(x>1){
            int k=find(x);//x映射到k
            h[k]=x;
            cnt[k]++;
            // cout<<k<<" "<<cnt[k]<<endl;
        }
    }
    long long ans=1;
    for(int i=0;i<N;i++){//遍历整个哈希表
        ans=ans*(cnt[i]+1)%mod;
    }
    cout<<ans;
    return 0;
}
```
## 约数之和
![约数个数，约数之和.jpg](https://cdn.acwing.com/media/article/image/2023/07/19/246003_a40595f625-约数个数，约数之和.jpg) 
```c++
//套约数和的公式
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
int n;
const int mod=1e9+7;
int main(){
    cin>>n;
    unordered_map<int,int> primes;//记录这个质因数出现的次数
    while(n--){
        int x;cin>>x;
        for(int i=2;i<=x/i;i++){
            while(x%i==0){
                primes[i]++;
                x/=i;
            }
        }
        if(x>1) primes[x]++;
    }
    ll ans=1;
    for(auto tmp:primes){
        int p=tmp.first,a=tmp.second;
        ll t=1;
        for(int i=1;i<=a;i++){//那个式子能转为递归式
            t=t*p+1;
            t%=mod;
        }
        ans=ans*t%mod;
    }
    cout<<ans;
    return 0;
}
```
## 最大公约数

### ==[裴蜀定理 - OI Wiki (oi-wiki.org)](https://oi-wiki.org/math/number-theory/bezouts/)==（不是很会）

### stl（直接记这个）

```
__gcd(a,b);
```
### 辗转相除法

```c++
（原理写在笔记上）
/*（直接从别人的题解复制过来了）
求两个正整数 a 和 b 的 最大公约数 d
则有 gcd(a,b) = gcd(b,a%b)
证明：
    设a%b = a - k*b 其中k = a/b(向下取整)
    若d是(a,b)的公约数 则知 d|a 且 d|b 则易知 d|a-k*b 故d也是(b,a%b) 的公约数
    若d是(b,a%b)的公约数 则知 d|b 且 d|a-k*b 则 d|a-k*b+k*b = d|a 故而d同时整除a和b 所以d也是(a,b)的公约数
    因此(a,b)的公约数集合和(b,a%b)的公约数集合相同 所以他们的最大公约数也相同 证毕#
*/
注意是余数和除数不断辗转，直到余数为0
int gcd(int a,int b){
    // while(b!=0){//循环写法
    //     int t=a%b;
    //     a=b;
    //     b=t;
    // }
    // return a;
    return b?gcd(b,a%b):a;//递归写法
}
```
## 欧拉函数
![欧拉函数.jpg](https://cdn.acwing.com/media/article/image/2023/07/19/246003_ea28096d25-欧拉函数.jpg) 
```c++
#include<bits/stdc++.h>
using namespace std;
//套公式：欧拉函数
int phi(int n){
    int ans=n;
    //分解质因数
    for(int i=2;i<=n/i;i++){
        if(n%i==0){
            ans=ans/i*(i-1);
            while(n%i==0) n/=i;
        }
    }
    if(n>1) ans=ans/n*(n-1);
    return ans;
}
int main(){
    int n;cin>>n;
    while(n--){
        int a;cin>>a;
        cout<<phi(a)<<endl;
    }
    return 0;
}
```
## 筛法求欧拉函数
 ![](https://sat02pap005files.storage.live.com/y4m0h502MHlBxldYpv8MzFXpleiWI8LEJauewVbIWqrbC4Ttk_FyspMk7qu3STLYRSOO-VXMdl-bhhswFbe-teziG57qUv96rdUalBJoFO6cEn9pVutXgdAGDtjOMLRlQurIf-9X3wCmgsaYVd51qyZK7lLXO0mzufYefOQLQBT-3slGIYQnq_6FbEjG14rqjHn?encodeFailures=1&width=1319&height=1102) 

```c++
时间复杂度只有O（n）
//用线性筛的同时算出所有欧拉函数
//要算所有欧拉函数的和，之前算的是一个个的
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e6+10;
int phi[N];
//eulers 欧拉函数：1~i，中有多少个数与i互质
int primes[N],cnt;//存下质数
bool st[N];//state表示状态
void get_phi(int n){
//get_eulers 在线性筛的同时算出所有的欧拉函数
    phi[1]=1;//1与1互质
    for(int i=2;i<=n;i++){
        if(!st[i]){
            primes[cnt++]=i;
            phi[i]=i-1;
        }
        for(int j=0;primes[j]<=n/i;j++){
            //这里的欧拉函数都是推出来的，推的过程看笔记
            st[primes[j]*i]=1;
            if(i%primes[j]==0){//呜呜，注意顺序
                phi[primes[j]*i]=primes[j]*phi[i];
                    //i本身就包含pj这个最小最因数
                break;
            }
            phi[primes[j]*i]=(primes[j]-1)*phi[i];
        }
    }
}

int main(){
    int n;cin>>n;
    get_phi(n);
    ll ans=0;
    for(int i=1;i<=n;i++){
        // cout<<phi[i]<<" ";
        ans+=phi[i];
    }
    cout<<ans;
    return 0;
}
```
## 快速幂
![快速幂.jpg](https://cdn.acwing.com/media/article/image/2023/07/19/246003_fded4b3226-快速幂.jpg) 
a^(k-1)*a^(k-1) = a^k

```c++
/*
快速幂：（具体看笔记）
    就是将指数拆成二进制之和
时间复杂度：O(log2(指数))
*/
//都搞为ll

#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
//非常容易爆，所以所有的数都搞为ll

ll qmi(ll a,ll b,ll c){//强制转一下类型
    //若用int，那么参与运算的第一个数最好转为ll
    //int*int很可能是会爆的
    ll ans=1%c;//这里写完整一下些，怕出现b=0,c=1的操蛋数据
    while(b){
        if(b&1){
            //取余2，为1；在这个数位上填1
            ans=ans*a%c;
        }
        a=a*a%c;//底数也要跟着2进制进位
        b>>=1;//等价于除2
    }
    return ans;
}
int main(){
    //数据比较多，用c语言输入输出
    int n;scanf("%d",&n);
    while(n--){
        int a,b,p;
        scanf("%d%d%d",&a,&b,&p);
        printf("%lld\n",qmi(a,b,p));
    }
    
    return 0;
}
```
## 快速幂求逆元

**乘法逆元定义:**
> 若整数 $b，m$ 互质，并且对于任意的整数 $a$，如果满足 $b|a$，则存在一个整数 $x$，使得 $a/b≡a \times x \pmod m$，则称 $x$ 为 $b$ 的模 $m$ 乘法逆元，记为 $b^{-1} \pmod m$。
>
> $b$ 存在乘法逆元的充要条件是 $b$ 与模数 $m$ 互质。当模数 $m$ 为质数时，$b^{m-2}$ 即为 $b$ 的乘法逆元。

**乘法逆元就是为了将除法传为乘法**



![快速幂求乘法逆元.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_2b8fbb7235-快速幂求乘法逆元.jpg) 
```c++
/*
这里是通过推公式推出来的（具体看笔记）
最后
    在a,p互质的前提下:
    x=a^(p-2)%p  （这里%p,更快速幂的取模原理一样）

然后强调一点：
    题目虽然给定了p是质数，但是并没有说明与a的关系
    根据乘法逆元的概念以及费马小定理的条件都是要p与a互质  
    一定是需要判断一下的
然后看到质数那么大，肯定是要使用快速幂的
*/
#include<bits/stdc++.h>
using namespace std;
//快速幂
typedef long long ll;//算快速幂时最好全弄为ll
ll qmi(ll a,ll b,ll c){//若为int乘时一定要转为ll
    ll ans=1;
    while(b){
        if(b&1) ans=ans*a%c;//二进制时这个位置上为1
        a=a*a%c;//底数要与二进制位置相映
        b>>=1;
    }
    return ans;
}
int  main(){
    int n;cin>>n;
    while(n--){
        int a,p;cin>>a>>p;
        //这里最好别使用逆元公式来判断，最好是从条件出发
        //当p=2是一个特例
        if(a%p==0) puts("impossible");
        else{//满足条件,套公式就好了
            cout<<qmi(a,p-2,p)<<endl; 
        }
    }
    return 0;
}
```
## 扩展欧几里得算法
```
给定 n 对正整数 ai,bi，对于每对数，求出一组 xi,yi，
使其满足 ai×xi+bi×yi=gcd(ai,bi)。
```
```
很推荐这篇题解
https://www.acwing.com/solution/content/1393/
```

![扩展中国定理.jpg](https://cdn.acwing.com/media/article/image/2023/08/07/246003_39de8c6c35-扩展中国定理.jpg) 
### 如果要写推荐这个写法
```c++
#include<bits/stdc++.h>
using namespace std;
/*
d=gcd(a,b)=gcd(b,a%b),当递归到gcd(d,0)时，
那对x=1,y=0是唯一确定，因此我们可以用这个迭代上去
那个递推公式看笔记,
然后y总是通过这个公式简化了计算，本质上也是这个公式
*/
int exgcd(int a,int b,int &x,int &y){
    if(!b) {//递归到b=0
        x=1,y=0;
        return a;
    }
    else{
        int d=exgcd(b,a%b,x,y);//除数变被除数，a%b变除数
        //递归到底返回时
        int x1=x,y1=y;//存返回时迭代的结果，用这个来推现在的
        //当前层的x,y
        x=y1,y=x1-a/b*y1;
        return d;
    }
}
int main(){
    int n;cin>>n;
    while(n--){
        int a,b;cin>>a>>b;
        int x,y;
        exgcd(a,b,x,y);
        cout<<x<<" "<<y<<endl;
    }
    return 0;
}
```
### y总回来是互相x，y值版（这样就不会覆盖原值）
```c++
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }else{
        int d=exgcd(b,a%b,y,x);
        /*注意看细节，将y和x的位置换了下
          然后我们x，y都是按地址传递，
          也就是说这个会改变原值，
          回来后x和y的值其实是互换的
          
          好处就是有利于运算，不会覆盖值
        */
        y-=a/b*x;
        return d;
    }
}
```
## 线性同余方程
```
给出a,b,m
使其满足 a×x≡b(mod m)，如果无解则输出 impossible。
```
![线性同余方程.jpg](https://cdn.acwing.com/media/article/image/2023/07/22/246003_ccf4dc8e28-线性同余方程.jpg) 
## 这里还涉及到了求解二元不定项方程
```c++
//具体的推导看笔记
#include<bits/stdc++.h>
using namespace std;
int exgcd(int a,int b,int &x,int &y){
    if(!b){
        x=1,y=0;
        return a;
    }else{
        int d=exgcd(b,a%b,y,x);//交换一下xy的值
        y-=a/b*x;//推公式时也交换一下
        return d;
    }
}
int main(){
    int n;cin>>n;
    while(n--){
        int a,b,m;cin>>a>>b>>m;
        int x,y;//先解出裴蜀定理
        int d=exgcd(a,m,x,y);
        //若能够能转化为裴蜀定理则说明有解,反之无解
        if(b%d) puts("impossible");
        else    cout<<(long long)x*b/d%m<<endl;
        //首先先将都乘(b/d)变回原式
        //这个取余m是通过通解得来的
        //作用是那他保持在整型
    }
    return 0;
}
```
## 扩展中国剩余定理
**表达整数的奇怪方式**
给定 $2n$ 个整数 $a_1,a_2,…,a_n$ 和 $m_1,m_2,…,m_n$，求一个最小的非负整数 $x$，满足 $\forall i \in [1,n],x \equiv m_i(mod\ a_i)$。
```
```
![扩展中国剩余定理.jpg](https://cdn.acwing.com/media/article/image/2023/07/23/246003_9c80cd5f29-扩展中国剩余定理.jpg) 
```c++
//扩展中国剩余定理
/*哎呀，真不容易呀,听不好懂的一题
    如果要使用这个中国剩余定理，必须满足m[i]之间互质
    这题显然不可能
  所以只能从式子出发，
    先推两个式子，发现他们竟然可以合成一个新的式子
    
  具体推理过程看笔记
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll exgcd(ll a,ll b,ll &x,ll &y){
    if(!b){
        x=1,y=0;
        return a;
    }else{
        ll d=exgcd(b,a%b,y,x);
        y-=a/b*x;
        return d;
    }
}
int main(){
    int n;cin>>n;
    ll a1,m1;cin>>a1>>m1;
    bool flag=1;
    for(int i=1;i<n;i++){
        ll a2,m2;cin>>a2>>m2;
        ll k1,k2;
        ll d=exgcd(a1,a2,k1,k2);
        if((m2-m1)%d){
            flag=0;
            break;//这里注意一下
        }
        k1*=(m2-m1)/d;
        ll t=a2/d;
        k1=(k1%t+t)%t;//k1化为最小正整数
        //合成新的式子
        m1=a1*k1+m1;
        a1=abs(a1/d*a2);//乘了k后正负号不要紧
    }
    if(flag){
        cout<<(m1%a1+a1)%a1;//算出最小非负整数x
    }else{
        cout<<-1;
    }
    
    return 0;
}
```
## 高斯消元解线性方程组

```
 n 个方程 n 个未知数的线性方程组（方程组中的系数为实数）
求解这个方程组。
```
![高斯消元解线性方程.jpg](https://cdn.acwing.com/media/article/image/2023/07/26/246003_176cd0362b-高斯消元解线性方程.jpg) 
```c++
时间复杂度：O(n^3)
//呜呜，模拟高斯消元有点麻烦
//详细过程和解释看笔记
#include<bits/stdc++.h>
using namespace std;
const int N=110;
const double eps=1e-6;//精度
int n;
double a[N][N];//用来存矩阵，也就是方程组的系数
int gauss(){//模拟高斯消元的步骤
    int r,c;//分别表示行列
    //先转化为完美阶梯型矩阵
    for(r=0,c=0;c<n;c++){//对列操作
        //1.先找到当前列中绝对值最大的那一行
            //做浮点除法，除个大数，精度会更好，误差小；顺便判断是否整行都是0
        int t=r;
        for(int i=r;i<n;i++){//可以从r+1开始
            if(fabs(a[i][c])>fabs(a[t][c])) 
                t=i;
        }
        if(fabs(a[t][c])<eps){//要加个精度，0可能被存乘0.00~几
            //都为0了这一列就没必要在继续了，但还要接着算才知道是哪种情况
        //不完美了，有一个凹陷
            continue;
        }
        
        //2.交换到最上面那一行
        swap(a[r],a[t]);//行交换
        
        //3.将当前行首位变为1
        for(int i=n;i>=c;i--){//注意主要涉及到整行的操作都要到n列
        //倒序的原因是避免首位过早变为1
            a[r][i]/=a[r][c];
        }
        
        //4.用最上面那行，将下面所有行的第c列变为0
        for(int i=r+1;i<n;i++){
            if(fabs(a[i][c])>eps){//当前行的第一个数不等于0，才有必要操作
                                    //别写里面了
                for(int j=n;j>=c;j--){//倒序原因同上
                    a[i][j]-=a[r][j]*a[i][c];//把首行的首位与当前行对齐
                }
            }
        }
        
        r++;//这上面所有操作做完才能下一行
    }
    //可以判断解的情况了
    if(r<n){//不是完美梯形
        for(int i=r;i<n;i++){//0=非0,无解
            if(fabs(a[i][n])>eps) return -1;
        }
        //0=0否则就是有无穷多组解
        return 1;
    }
    //如果是唯一解，解出每个数a[i][n]
    for(int i=n-1;i>=0;i--){//从后往前，只有最后一行确定是一个未知数
        //每行的系数只保留一个1
        for(int j=i+1;j<n;j++){//虽然是整行操作,但结果只需最后一列
            a[i][n]-=a[i][j]*a[j][n];
        }
    }
    return 0;
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n+1;j++)//多了一行运算结果
            cin>>a[i][j];
    
    int t=gauss();
    if(t==0){
        for(int i=0;i<n;i++){
            printf("%.2lf\n",a[i][n]);
        }
    }else if(t==1) puts("Infinite group solutions");
    else           puts("No solution");
    
    return 0;
}
```
## 高斯消元解异或线性方程组
```
求解 n 个方程 n 个未知数的异或线性方程组
（形式看下面笔记）
```
![高斯消元解异或线性方程组.jpg](https://cdn.acwing.com/media/article/image/2023/07/26/246003_d41aa88e2b-高斯消元解异或线性方程组.jpg) 
```c++
//关键点在于：异或等价于不进位加法
//所以又能转化为高斯消元
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int a[N][N];
int n;
int gauss(){
    int r,c;
    for(r=0,c=0;c<n;c++){
        int t=r;
        //1.找到当前列非0的行
        for(int i=r;i<n;i++){
            if(a[i][c]){
                t=i;
                break;
            }
        }
        //都为0，下面几步就没必要了
        if(!a[t][c]) continue;
        //2.交换到最上面
        swap(a[t],a[r]);
        //3.用首行 将后面行 这一列都消为0
        for(int i=r+1;i<n;i++){
            if(a[i][c]){//本就是0，就没必要了
                for(int j=n;j>=c;j--){//这里前后都没差
                    a[i][j]^=a[r][j];
                }
            }
        }
        r++;
    }
    if(r<n){//不是完美梯形
        for(int i=r;i<n;i++){
            if(a[i][n]) return -1;//0=非0，无解
        }
        return 1;//0=0，则多组解
    } 
    //解出来,只需要a[i][n]
    for(int i=n-1;i>=0;i--){//从后往前，只有最后一行确定一个
        for(int j=i+1;j<n;j++){
            // 两种写法都是等价的
            // if(a[i][j]){
            //     a[i][n]^=a[j][n];
            // }
            a[i][n]^=a[i][j]&a[j][n];
        }
    }
    return 0;
}
int main(){
    cin>>n;
    for(int i=0;i<n;i++)
        for(int j=0;j<n+1;j++)
            cin>>a[i][j];
    int t=gauss();
    if(t==0)for(int i=0;i<n;i++) cout<<a[i][n]<<endl;
    else if(t==1)   puts("Multiple sets of solutions");
    else            puts("No solution"); 
        
    return 0;
}
```

## 求组合数

### 1. 递推式求组合数 $\quad O(n^2)$

题型:给定两个正整数a与b,求$C_{a}^{b} \quad mod(1e9+7)$   （b<=a<=2000）
递推式:

$$
C_{a}^{b}=C_{a-1}^{b-1}+C_{a-1}^{b}
$$
![组合数1.jpg](https://cdn.acwing.com/media/article/image/2023/07/26/246003_1ab2faeb2b-组合数1.jpg) 
```c++
//这里用不了n!来预处理，因为分别取余运算只有除法不满足
//具体推理过程看笔记
#include<bits/stdc++.h>
using namespace std;
const int N=2010,mod=1e9+7;
int c[N][N];//注意：c[a][b]表示从a中选b个
void init(){
    for(int i=0;i<=2000;i++){
        for(int j=0;j<=i;j++){
            if(!j){//选了0个
                c[i][j]=1;
            }else{
                c[i][j]=(c[i-1][j]+c[i-1][j-1])%mod;
            }
        }
    }
}
int main(){
    init();
    int n;cin>>n;
    while(n--){
        int a,b;cin>>a>>b;
        cout<<c[a][b]<<endl;
    }
    return 0;
}
```
### 2. n!和逆元直接求 O(nlog(n))

mod=1e9+7,1≤b≤a≤10e5，注意这里模数p比ab大
![组合数2.jpg](https://cdn.acwing.com/media/article/image/2023/07/27/246003_4f544d7d2c-组合数2.jpg) 
```c++
/*
想利用n!直接做，但是不能够直接取模。
涉及到除法只能用乘法逆元（快速幂求）来做，
把除法转化为乘法，才能用阶乘做
(补充说明看笔记)
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e5+10,mod=1e9+7;
//别轻视了mod这是一个质数(费马小定理->快速幂求)
int fact[N],infact[N];//特别注意int*int,最好转为ll
//快速幂(直接转为ll,最方便)
ll qmi(ll a,ll b,int p){
    ll ans=1;
    while(b){
        if(b&1) ans=ans*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return ans;
}
//阶乘预处理
void init(){
    fact[0]=infact[0]=1;
    for(int i=1;i<=1e5;i++){
        fact[i]=(ll)fact[i-1]*i%mod;
        infact[i]=(ll)infact[i-1]*qmi(i,mod-2,mod)%mod;
            //这里运用了乘法逆元是完全积性函数
    }
}
int main(){
    init();
    int n;cin>>n;
    while(n--){
        int a,b;cin>>a>>b;
        //c[a][b]=a!/(b!(a-b)!)
        cout<<(ll)fact[a]*infact[b]%mod*infact[a-b]%mod<<endl;
        //注意int*int*int连ll都会爆
    }
    return 0;
}
```
### 3. 卢卡斯定理求 O(log p N*(p+log 2 p))

1≤b≤a≤1e18,1≤p≤1e5
 ![卢卡斯定理.jpg](https://cdn.acwing.com/media/article/image/2023/08/07/246003_dc26577a35-卢卡斯定理.jpg) 
```
证明（了解，不要求掌握）可以看
https://www.acwing.com/file_system/file/content/whole/index/content/8148298/
或这是《算法竞赛》
```
```c++
/*
由于质数小于a,b，所以不一定能用费马小定理
且阶乘预处理本身复杂度就为O(nlogn)不够

原理就是那个公式，然后不断递归求下去就行
*/
//记住是从a中选b个
//竞赛中写最好都写为ll
//别忘记取余了，int*int*int是会爆的
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
ll qmi(ll a,ll b,ll p){
    ll ans=1;
    while(b){
        if(b&1) ans=ans*a%p;
        b>>=1;
        a=a*a%p;
    }
    return ans;
}
//这里用组合数最基本的求法：C(a,b)=A(a,b)/b!
int C(ll a,ll b,int p){
    if(b>a) return 0;//这里a不一定大于b(小优化)
        //其实没有这句也关系,后面算的时候会出现0
    if(b>a-b) b=a-b;//用组合数运算优化
    ll x=1,y=1;//int*int可能会爆
    for(int i=0;i<b;i++){
        x=x*(a-i)%p;
        y=y*(i+1)%p;
    }
    return x*qmi(y,p-2,p)%p;
        //提到外面做转化为逆元相乘，这是个小优化
}
int lucas(ll a,ll b,int p){//注意一下ab的类型
    if(a<p&&b<p) return C(a,b,p);
    return (ll)C(a%p,b%p,p)*lucas(a/p,b/p,p)%p;
    //靠，这里要注意int*int,而且要记得取余
}
int main(){
    int n;cin>>n;
    while(n--){
        ll a,b;int p;
        cin>>a>>b>>p;
        cout<<lucas(a,b,p)<<endl;
    }
    return 0;
}
```
### 4. 阶乘分解+高精乘

有精度要求的题：1≤b≤a≤5000,使用高精度运算

![组合数4.jpg](https://cdn.acwing.com/media/article/image/2023/08/07/246003_638708e735-组合数4.jpg)  
```
这里可以先去掌握这题：
https://www.acwing.com/problem/content/199/
```
```c++
/*思路：
    组合数用阶乘表示,
    将n!分解质因数后（难点）,
    直接转化为次数减就行,
    最后用一个高精乘求回去就行
*/
#include<bits/stdc++.h>
using namespace std;
const int N=5000;
//线性筛
int primes[N],cnt;
bool st[N];
void get_primes(int n){
    for(int i=2;i<=n;i++){
        if(!st[i]) primes[cnt++]=i;//没被筛过就是质数
        for(int j=0;primes[j]<=n/i;j++){//用最小质因数筛
            st[primes[j]*i]=1;
            if(i%primes[j]==0) break;//保证是最小质因数
        }
    }
}
int get(int n,int p){
    int sum=0;
    while(n){
        sum+=n/p;
        n/=p;
    }
    return sum;
}
vector<int> operator*(vector<int> &a,int b){
    vector<int> c;
    int t=0;//存借位
    for(int i=0;i<a.size();i++){
        t+=a[i]*b;
        c.push_back(t%10);
        t/=10;
    }
    while(t){
        c.push_back(t%10);
        t/=10;
    }
    return c;
}
//存每个质数的倍数
int sum[N];
int main(){
    int a,b;cin>>a>>b;
    //求出所有要用到的质数
    get_primes(a);
    //求组合数每个质数的次数
    for(int i=0;i<cnt;i++){
        int p=primes[i];
        sum[i]=get(a,p)-get(b,p)-get(a-b,p);
            //组合数转为阶乘形式
    }
    //从分解质因数的形式求回去
    vector<int> ans;
    ans.push_back(1);
    for(int i=0;i<cnt;i++){//枚举质数
        for(int j=0;j<sum[i];j++){//看是几次方
            ans=ans*primes[i];
        }
    }
    for(int i=ans.size()-1;i>=0;i--){
        cout<<ans[i];
    }
    return 0;
}
```
$C^b_a=\frac{A^b_a}{A^a_a}$为什么按运算顺序直接算下来不会出现分数，看下面求阶乘那边？
（这里就用瞪眼法很粗显的解释一下）
运算过程：$b/1*(b-1)/2*(b-2)/3~$
偶数每两个出现一个，三的倍数每三个出现~以此类推
这种做法相当巧合的能整除，每个除数都能找到相应的约数

```c++
直接用高精度做很容易超时，阶乘的过程会比分解质因数乘得多
#include<bits/stdc++.h>
using namespace std;
const int N=5000;
#define VI vector<int>
#define pk push_back
//0表示个位，慢慢往后加
VI operator*(VI &a,int b){//a*b
    VI c;
    int t=0;
    for(int i=0;i<a.size();i++){
        t+=a[i]*b;
        c.pk(t%10);
        t/=10;
    }
    while(t){//没接完
        c.pk(t%10);
        t/=10;
    }
    return c;
}
VI operator/(VI &a,int b){//a/b
    VI c;
    int t=0;//借位（前面没除完）
    for(int i=a.size()-1;i>=0;i--){//除法模拟一下是从后往前
                //注意个数要-1
        t=t*10+a[i];
        c.pk(t/b);
        t%=b;
    }
    reverse(c.begin(),c.end());//翻转函数注意看一下
    //除前导0
    while(c.back()==0&&c.size()>1){
        c.pop_back();
    }
    return c;
}
int main(){
    int a,b;cin>>a>>b;
    VI ans;
    ans.pk(1);
    for(int i=0;i<b;i++){
        ans=ans*(a-i);
        ans=ans/(i+1);
        //换成这样后神奇的能过了
        //注意看这里很关键，这样好像很神奇的不会产生精度误差
    }
    for(int i=ans.size()-1;i>=0;i--){
        cout<<ans[i];
    }
    return 0;
}
```
## 卡特兰数

**满足条件的01序列**
```
给定 n 个 0 和 n 个 1，它们将按照某种顺序排成长度为 2n 的序列，
求能够满足任意前缀序列中 0 的个数都不少于 1 的个数的序列有多少个。
输出的答案对 109+7 取模。
```
```
呜呜虽然y总讲得挺详细的，但我太菜了
卡特兰数还有许多运用，后面还可以看看这个：
https://www.cnblogs.com/Morning-Glory/p/11747744.html
```
![卡特兰数.jpg](https://cdn.acwing.com/media/article/image/2023/08/07/246003_ffcf822f35-卡特兰数.jpg) 


![](https://cdn.acwing.com/media/article/image/2020/02/22/6828_9476d97655-Catalan.png) 
([图片来源](https://www.acwing.com/solution/content/8907/) )
```c++
/*
卡特兰数的式子中含有组合数：
(还是那句话,涉及都除法的取余，一般都是要转化为逆元)
由于模数为1e9+7,比a，b都大，所以能用快速幂求逆元（费马小定理）

像这种只需求一个的一般都是没有必要用递推或着阶乘预处理
一般直接从最基本的式子求一下就行
C[a][b]=A[a][b]/b!   从a中选b个
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int mod=1e9+7;
//qmi(a,p-2,p)求乘法逆元:
    //费马小定理：a^(p-2)*a 同余 1(mod p)
ll qmi(ll a,ll b,ll p){
    ll ans=1;
    while(b){
        if(b&1) ans=ans*a%mod;
        b>>=1;
        a=a*a%mod;
    }
    return ans;
}
int main(){
    int n;cin>>n;
    int a=2*n,b=n;
    //优化：最后在一块处理
        //乘法是逆元是积性函数,可以分别求逆元乘，也可一块乘在求逆元
    ll x=1,y=1;//这里用来记录分子分母
    for(int i=0;i<b;i++){
        x=x*(a-i)%mod;//A[a][b]
        y=y*(i+1)%mod;//b!
    }
    cout<<qmi(n+1,mod-2,mod)*x%mod*qmi(y,mod-2,mod)%mod;
    //int*int*int连ll都会爆，要提前取余
    return 0;
}
```
[堆栈出栈顺序个数详解——卡兰特数](https://blog.csdn.net/wangrusi/article/details/99001938) 
入栈时表示0，出栈时表示1

## 容斥原理

**能被整除的数**
![容斥原理.jpg](https://cdn.acwing.com/media/article/image/2023/08/01/246003_7fc161e930-容斥原理.jpg) 
```c++
二进制枚举O(2^m*m)
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=20;
int p[N];//存下质数
int main(){
    int n,m;cin>>n>>m;
    for(int i=0;i<m;i++) cin>>p[i];
    //这里枚举可以一般用二进制或者是dfs
    //二进制枚举所有可能
    ll ans=0;
    for(int i=1;i<(1<<m);i++){//从1开始是个小细节
        int cnt=0;//存1的个数
        ll t=1;//存除数，多个质数相乘可能会爆
        for(int j=0;j<m;j++){//看各个数位的情况
                //当为1，表示有这个质数
            if(i>>j &1){
                if(t*p[j]>n){//已经比n大了，没必要继续了
                    t=-1;
                    break;
                }
                t*=p[j];
                cnt++;
            }
        }
        if(t!=-1){
            if(cnt&1) ans+=n/t;//奇数+
            else      ans-=n/t;//偶数-
        }
    }
    cout<<ans;
    return 0;
}
```
```c++
dfs枚举：O(2^m)
ll ans=0;
ll t=1;//记录除数
void dfs(int i,int x){//选与不选模板
    //i表示第i个，选了x个
    if(t>n)  return;
    if(i==m){//呜呜，记住是到n时才判断答案
        if(x){
            if(x&1) ans+=n/t;
            else    ans-=n/t;
        }
        return;
    }
    t*=p[i];
    dfs(i+1,x+1);//选
    t/=p[i];
    dfs(i+1,x);//不选
}

dfs(0,0);
```
## 公平组合游戏（博弈论）
## Nim游戏
```
给定 n 堆石子，两位玩家轮流操作，
每次操作可以从任意一堆石子中拿走任意数量的石子（可以拿完，但不能不拿），
最后无法进行操作的人视为失败。
问如果两人都采用最优策略，先手是否必胜。
```




![IMG20230807195710.jpg](https://cdn.acwing.com/media/article/image/2023/08/07/246003_a72ae2bd35-IMG20230807195710.jpg) 

 补充一下：证明的③是用反证法，变后的式子若还是0
```
先手必败状态：a1 ^ a2 ^ a3 ^ ... ^an = 0
先手必胜状态：a1 ^ a2 ^ a3 ^ ... ^an ≠ 0

然后异或和等价于不进制加法，还是满足加法的各种性质的
所以只要每个a[i]分别算一下就行
```
## 台阶-Nim游戏

```
有一个n级台阶的楼梯，其中第i级台阶上有a[i]个石子(i>=1)
两位玩家轮流操作，每次操作可以从任意一级台阶上拿若干个石子放到下一级台阶中（不能不拿）。
已经拿到地面上的石子不能再拿，最后无法进行操作的人视为失败。
问如果两人都采用最优策略，先手是否必胜。
```
![台阶nim.png](https://cdn.acwing.com/media/article/image/2023/08/07/246003_581c6be735-台阶nim.png) 
```c++
/*
y总的思路听不懂，可以看看下面评论区的思路,以及一些题解
https://www.acwing.com/solution/content/13187/

就还是转化为最经典的拿石子的Nim游戏
就是第一个台阶能拿1次拿完，第二个拿2次，第三个拿3次,以此类推
无法操作的失败
等价于
    第一个台阶有1堆石子，第二个台阶有2堆石子，以此类推
    (这里不能将同台阶这几堆石子合起来看，一定要分开一次看，第一堆对应第一次移动)
    然后不能再拿石子的
    无法操作的失败
这样就转化为了Nim游戏，对于偶数阶取异或一定为0
所有只看奇数阶即可

综上，先手必胜的条件就是：a1⊕a3⊕a5⊕…⊕ak=x
*/
```
每次只能对其中一个操作一般都是独立的，对后续是无影响的
想台阶nim游戏，前一次取完后一次才能取
```c++
    int ans=0;
    for(int i=1;i<=n;i++){
        int a;cin>>a;
        if(i&1) ans^=a;
    }
    if(ans==0) puts("No");
    else       puts("Yes");
```
**集合—Nim游戏**
## SG函数
```
给定 n 堆石子以及一个由 k 个不同正整数构成的数字集合 S。

现在有两位玩家轮流操作，每次操作可以从任意一堆石子中拿取石子，
每次拿取的石子数量必须包含于集合 S，最后无法进行操作的人视为失败。

问如果两人都采用最优策略，先手是否必胜。
```

![IMG20230807191831.jpg](https://cdn.acwing.com/media/article/image/2023/08/07/246003_81e2d29235-IMG20230807191831.jpg)  
![集合Nim2.jpg](https://cdn.acwing.com/media/article/image/2023/08/07/246003_a062f3a035-集合Nim2.jpg) 


 时间复杂度大概是：O(n*最大石子数)

```c++
/*(还得再看)
哎呀呀，智商又不够用了，真抽象，
有种知识从脑子踩过的感觉，但是又不留痕迹

这题的本质就是利用sg函数又变成Nim游戏
    对于只有一堆:
        将每一堆石子转化为他接下来可能的局面（0<=i< sg(x)）
        当值为0,又是一个必败的局面
        让对手走的每一步都维持在值为0的局面
就是他能在每一堆变成比sg(x)小的任意个局面
                    (从中取任意的石子)
只要最后面对所有sg(x_i)都是0，就是败者
胜者某个操作后让每一堆都维持这个结果，且这是一个不断减的过程
这样又变成了一个Nim游戏
*/
#include<bits/stdc++.h>
using namespace std;
const int N=110,M=1e4+10;
int n,m;
int s[N];//存每次能拿的石头个数
int f[M];//存每个数对应的sg值
//每个数在数字集合S中，对应的sg值是确定的,跟那几堆的关系不大
void init(){//sg函数初始化
    memset(f,-1,sizeof f);
}
int sg(int x){//求x个数sg函数的值
    if(f[x]!=-1) return f[x];//已经求过了
    // unordered_map<int,int> h;//用哈希表存接下来状态的状态的sg值
    // unordered_set<int> h;
    set<int> h;//用有序的情况甚至稍微快点，以后若要存的超过1e5用有序的
    for(int i=0;i<m;i++){
        int ne=x-s[i];//取完s[i]后，剩下的个数
        // if(ne>=0) h[sg(ne)]=1;//递归求出，并标记一下 
        if(ne>=0)   h.insert(sg(ne));
    }
    for(int i=0;;i++){//sg函数的定义找到集合没有的最小自然数
        if(h.count(i)==0){//看i是否出现次数是0,等价于h[i]==0
            f[x]=i;
            return i;//顺便结束循环
        }
    }
}
int main(){
    cin>>m;//s集合个数
    for(int i=0;i<m;i++) cin>>s[i];
    cin>>n;
    int ans=0;
    init();
    for(int i=0;i<n;i++){
        int a;cin>>a;
        ans^=sg(a);
    }
    if(ans==0) puts("No");
    else       puts("Yes");
    return 0;
}
```
## 拆分-Nim游戏

```
给定 n 堆石子，两位玩家轮流操作，
每次操作可以取走其中的一堆石子，变成新的两小堆
（新堆规模可以为0，且两个新堆的石子总数可以大于取走的那堆石子数），
最后无法进行操作的人视为失败。
问如果两人都采用最优策略，先手是否必胜。
```
![拆分nim.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_f36b2ffc35-拆分nim.jpg) 
```c++
核心思想：用sg函数+多个局面的的sg值，转化为基础Nim游戏
但最难理解也是这个sg函数上，这里是用他的定理
#include<bits/stdc++.h>
using namespace std;
const int N=110;
int n;
int f[N];//存下相应的sg函数
void init(){
    memset(f,-1,sizeof f);
}
int sg(int x){//找不属于后继sg集合的最小自然数
    if(f[x]!=-1) return f[x];
    unordered_set<int> h;
    //由于小于100个，且只要判断是否出现过，所以使用哈希集合
//计算所有后继状态的sg函数
    for(int i=0;i<x;i++)//枚举可能的组合
        for(int j=0;j<=i;j++)
            h.insert(sg(i)^sg(j));
//从小到大找没有的自然数(注意：这里没有啥规律)
    for(int i=0;;i++){
        if(!h.count(i)){
            f[x]=i;
            return i;
        }
    }  
}
int main(){
    cin>>n;
    init();
    int ans=0;
    for(int i=0;i<n;i++){
        int a;cin>>a;
        ans=ans^sg(a);
    }
    if(ans) puts("Yes");//可以让下家一直保持0
    else    puts("No");
    return 0;
}
```

## 麦乐鸡定理：

对于两个互质的正整数 $ a, b $，最大的不能用 $ ax+by $ 所表示的正整数为 $ ab-a-b $。其中 $ x,y $ 为非负整数

# 动态规划：

## ==闫式dp方法整理==

### 1. 使用场景：
1). 能一个个 选/删/改/增/替
    (特别说明下选：可以是选不选当前个，或者选几个，可以是选这个位置的状态)
2). 分解或者合并
都可以试一下

### 2. 状态表示：
1). 确定表示的维度
2). 集合：就是说明(i,j,k)表示什么方案
3). 属性：（一般就是答案的要求）max,min,数量

先从低维开始一维一维慢慢加，`f[i]+[j]+[k]`，表示的条件不够就加维度
`f[i][j][k]`一般是要求出所有可能的状态（最少最少都要包含答案的那个状态）

举几个例子吧：

1. 背包类问题：一共有n个物品，都有各自的价值，背包总重量不超过m的，使总价值最大
   `f[i][j]`:集合：选第i个物品，总重量不超过j的方案（最少最少都要包含答案状态）
           属性：max的总价值
2. 走到(i,j)这个位置的方案数
   `f[i][j]`：集合：表示为走到(i,j)位置的方案
     属性：个数
3. 有n个数，能否被k整除
   `f[i][j]`:集合：选第i个数，余数为j的方案
    属性：个数
       等等等

## 3. 状态计算：（推f[i]+[j]+[k]的公式)
就是前面状态有哪几种能到`f[i][j][k]`这个状态
划分方法：（那个圆圈被划了几个部分）
**同时一定要注意限制条件**
举个例子：

1. 用当前物品选不选，选几个来划分

2. 当前位置，应该选哪个（比如题目提供的选择，像什么颜色啊，方块的种类啊）
   
2. 可能是**前一个**选或不选也能是状态
   
    ……
    
    当感觉`f[i][j]`比较难推，可以先举几个例子，一个个找规律：
    先推推看`f[i][0],f[i][1]`的公式之类的

## 4. ==初始化==（这个就要看具体情况了）

1) 求最大时，一般要把所有较小化
   求最小时，一般要把所有较大化
2) 然后一般就是看递推的边界，没有东西时候或者起点状态


## 优化：(这一块我掌握的不好)
滚动数组：将状态计算的每一个维度都是单向的（加或减）
二进制优化

可以选无限个时，试一下完全背包的推公式

-------




# 背包大专题
## 01背包问题    O(n^2)
```
有 N 件物品和一个容量是 V 的背包。每件物品只能使用一次。
第 i 件物品的体积是 vi，价值是 wi。
求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。
```
![01背包.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_d0c2960235-01背包.jpg) 
```c++
#include<iostream>
#include<algorithm>
using namespace std;
const int maxn=1e4+10;
int f[maxn]={0};
int main(){
    int n,V;
    cin>>n>>V;
    for(int i=0;i<n;i++){
        int v,w;
        cin>>v>>w;
        for(int j=V;j>=v;j--){
            f[j]=max(f[j],f[j-v]+w);
            // cout<<j<<"  "<<f[j]<<"  ";
        }
        // cout<<endl;
    }
    cout<<f[V];
    return 0;
}
```
## 完全背包
![完全背包.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_db74214c35-完全背包.jpg) 
```c++
#include<bits/stdc++.h>
using namespace std;
int f[1010];
int main(){
    int N,V;
    cin>>N>>V;
    for(int i=1;i<=N;i++){
        int v,w;
        cin>>v>>w;
        for(int j=v;j<=V;j++){//体积不能为负
           f[j]= max(f[j],f[j-v]+w);
        }
    }
    cout<<f[V];
    return 0;
}
```
## 多重背包问题（暴力） 小于O(n^3)
```
第 i 种物品最多有 si 件，每件体积是 vi，价值是 wi。
```
```
如果有存下上一个i-1的结果还好，
但是如果采用滚动数组优化:
    就要注意是否前面的值是否已经被更新过了
        （已经发生了串联更新,同个i中，值已经被覆盖）
    这次f[i][j]中用到了那些值，这些值就要比这个晚更新
```
![多重背包1.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_1ddf106e35-多重背包1.jpg) 
特别注意下：那个max的性质，很基础很重要
```c++
y总的思路，当时没完全理解，自己写一直写错

一维滚动数组优化改变了循环循序（i->j->k）
这样才不会发生串联更新，只用上一层的数据
#include<bits/stdc++.h>
using namespace std;
int f[110];
int main(){
    int N,V;
    cin>>N>>V;
    for(int i=1;i<=N;i++){
        int v,w,s;
        cin>>v>>w>>s;
        for(int j=V;j>=v;j--){
            for(int k=1;k*v<=j&&k<=s;k++){
                f[j]=max(f[j],f[j-k*v]+k*w);
            }
        }
        
    }
    cout<<f[V];
    return 0;
}
```
**多重背包问题2**
## 二进制配合01背包 O(N logS V)
![多重背包例子.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_0e1a774735-多重背包例子.jpg) 
![多重背包.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_13592e6635-多重背包.jpg) 
![多重背包2.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_18cd3dc735-多重背包2.jpg) 
```c++
/*多重背包思路：
(其实是利用了max的性质，可以结合死拆理解一下)
总是去往01背包上靠(具体才是要看笔记)
基本思路：
    二进制优化：
        一个一个物品去加(死拆的思路)，复杂度过高了，肯定会超时.
        将s个物品拆成不同的物品：（2^0,2^1,……,2^log2s,C）,
              将这些合起来能表示取0~s个物品，谁的结果max
              
像这种要表示出中间所有的数，可以是用而二进制表示法，max不会遗落其中的结果
*/
#include<bits/stdc++.h>
using namespace std;
const int maxn=1.1e4;
int v[maxn],w[maxn];//log2(maxs)*1000约为11000
    //存下拆分后的物品,s个数已经不用存了，在后面求回去的过程会自己凑出来
int f[2010];
int main(){
    int N,V;
    cin>>N>>V;
    int cnt=-1;
    //第i个物品又去合成新的二进制版物品
    //新的物品表示为（空间为k*v，价值为k*w）
    for(int i=0;i<N;i++){
        int a,b,s;
        cin>>a>>b>>s;
        //对个数进行拆分
        int k=1;//表示有几个
        while(k<s){//这里用的是队列存
            cnt++;
            v[cnt]=k*a;
            w[cnt]=k*b;
            s-=k;
            k*=2;
        }
        if(s>0){
            cnt++;
            v[cnt]=s*a;
            w[cnt]=s*b;
        }
    }
    //01背包
    for(int i=0;i<=cnt;i++){
        //一维滚动数组优化，要不然数组太多了
        // cout<<v[i]<<"   "<<w[i]<<endl;
        for(int j=V;j>=v[i];j--){
            f[j]=max(f[j],f[j-v[i]]+w[i]);
            // cout<<"f"<<j<<"= "<<f[j]<<";";
        }
        // cout<<endl;
    }
    // for(int j=0;j<=V;j++){
    //     cout<<f[j]<<" ";
    // }
    cout<<f[V];
    return 0;
}
```
## 分组背包
![分组背包.jpg](https://cdn.acwing.com/media/article/image/2023/09/14/246003_d472818353-分组背包.jpg) 
```c++
第一版：二维数组版（简单好记）
#include<bits/stdc++.h>
using namespace std;
int f[110][110];
int main(){
    int N,V;
    cin>>N>>V;
    //f[i,j]现在的i表示每一组，体积不超过j
    //转话为一组为单位的二维01背包，一维滚动数组，会发生同组更新，很难操作
    //100*100*100数据范围允许
    for(int i=1;i<=N;i++){
        int s;
        cin>>s;
        for(int j=1;j<=V;j++){
            //初始化操作，方便后续进行
            f[i][j]=f[i-1][j];
        }
        while(s--){
            int v,w;
            cin>>v>>w;
            for(int j=1;j<=V;j++){
                if(j>=v){
                    f[i][j]=max(f[i][j],f[i-1][j-v]+w);
                }
            }
        }
    }
    
    cout<<f[N][V];
    
    
    return 0;
}
```



```c++
现在是一维滚动数组优化（这个比较容易出错）
#include<bits/stdc++.h>
using namespace std;
int f[110]={0};
int main(){
    int N,V;
    cin>>N>>V;
    //f[j]体积不超过j
    //转话为一组为单位的二维01背包，一维滚动数组
    for(int i=1;i<=N;i++){
        int s;
        cin>>s;
        int v[110]={0},w[110]={0};
        for(int k=1;k<=s;k++){
            cin>>v[k]>>w[k];
        }
        for(int j=V;j>=1;j--){
            for(int k=1;k<=s;k++){//这个条件一定要放下面，不然会中止循环
                if(j>=v[k])
                    f[j]=max(f[j],f[j-v[k]]+w[k]);
            }
        }
    }
    cout<<f[V];
    return 0;
}
```
# 线性dp
**状态表示的关键：找当前状态与前面的状态的关系**
**关键点：所有的操作都是针对当前状态，针对a[i],b[j]**
```
画图，进行的操作：
    不重不漏的分出所有情况（最好就只针对a[i]），
    根据操作：
        1）.若是添加数，则直接在a[i]后面加上个数
        2）.不选a[i]或这是删掉a[i],则直接把a[i]删掉
        3）.替换a[i],则直接将a[i]换成目标值即可
    然后将：a[i]和b[j]中把相等的去掉
    
看剩下的表示什么，以及跟后面的等式
```
## 数字三角形
```
给定一个如下图所示的数字三角形，
从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，
一直走到底层，要求找出一条路径，使路径上的数字的和最大。
```
![数字三角形.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_93c8da2a35-数字三角形.jpg) 
```c++
//自己做的思路：才用自上而下，这样才好将循环合并
//从1开始，避免越界，f[i,j]=max(f[i-1,j],f[i-1,f-1])+w[j];
//用滚动数组优化

#include<bits/stdc++.h>
using namespace std;
int f[510]={0};

int main(){
    int n;
    cin>>n;
    memset(f,-10,sizeof(f));//有负数不能简单的赋为0
    int ans=f[0];
    cout<<ans<<endl;
    cin>>f[1];
    for(int i=2;i<=n;i++){
        int l[510];
        for(int j=1;j<=i;j++){
            cin>>l[j];
        }
        for(int j=i;j>=1;j--){
            f[j]=max(f[j],f[j-1])+l[j];
            // cout<<f[j]<<"  ;";
        }
    }
    
    for(int i=1;i<=n;i++){
        // cout<<f[i]<<" ";
        if(ans<f[i]){
            ans=f[i];
        }
    }
    cout<<ans;
    
    return 0;
}
```
## 最长上升子序列
```
给定一个长度为 N 的数列，求数值严格单调递增的子序列的长度最长是多少。
子序列：不破坏原来的相对位置
```
![最长上升子序列.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_68ce2c0835-最长上升子序列.jpg) 
![最长上升子序列2.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_6e0e833e35-最长上升子序列2.jpg) 
**dp O(n^2)**
```c++
//状态表示f[i]表示集合从1~j中以a[i]结尾的上升子序列（必需理解这个）   属性：max
//状态计算，f[i]=max(f[j]+1)(a[j]<a[i])(1-i-1)

#pragma GCC optimize(2)
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e3+10;
int f[maxn],a[maxn];
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        cin>>a[i];
        f[i]=1;//初始化
        for(int j=1;j<=i-1;j++){
            if(a[j]<a[i]){
                f[i]=max(f[j]+1,f[i]);
            }
        }
    }
    int ans=0;
    for(int i=1;i<=n;i++){
        ans=max(ans,f[i]);
    }
    cout<<ans;
    return 0;
}
```
**贪心+二分 O(n*logn)**
```
题解中最难理解的地方在于栈中序列虽然递增，
但是每个元素在原串中对应的位置其实可能是乱的，
那为什么这个栈还能用于计算最长子序列长度？
    实际上这个栈【不用于记录最终的最长子序列】，
    而是【以stk[i]结尾的子串长度最长为i】
    或者说【长度为i的递增子串中，末尾元素最小的是stk[i]】。
    
    理解了这个问题以后就知道为什么新进来的元素要不就在末尾增加，
    要不就替代第一个大于等于它元素的位置。
    
这里的【替换】就蕴含了一个贪心的思想：
    对于同样长度的子串，我当然希望它的末端越小越好，
    这样以后我也有更多机会拓展。
```
```c++
//q[i]表示长度为i的结尾，并使结尾最小化
    //注意理解这里，结尾越小机会越多
//对于每个a[i]需要刚好大于等于的值,也就是其中的最小值
//根据视频所讲这个q这个数列有严格的单调性，所以我们能用二分
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int a[maxn],q[maxn];
int main(){
    int n;
    cin>>n;
    int len=0;//计入q的长度，注意不是编号
    for(int i=0;i<n;i++){
        cin>>a[i];
    /*模板写法，会涉及到一点边界问题，尽量用函数
        //二分
        int l=0,r=len;
        while(l<r){//找符合条件的最小值,用向左模板
            int mid=(l+r)>>1;
            if(q[mid]>=a[i]){
                r=mid;
            }else{
                l=mid+1;
            }
        }
        q[l]=a[i];
        len=max(len,l+1);
        // printf("l=%d;ql=%d;len=%d\n",l,q[l],len);
    */
        int l=lower_bound(q,q+len,a[i])-q;
        //找不小于a[i]的第一个数
        q[l]=a[i];
        len=max(len,l+1);
        // printf("l=%d;ql=%d;len=%d\n",l,q[l],len);
    }
    cout<<len;
    return 0;
}
```
## 最长公共子序列
**这个还不是很会（再看）**
```
给定两个长度分别为 N 和 M 的字符串 A 和 B，
求既是 A 的子序列又是 B 的子序列的字符串长度最长是多少。
```
```c++
//唉，这个算法理解起来是有难度的
/*状态表示：f[i][j]
            集合：表示a[1~i]和b[1~i]的公共子序列
            属性：max
  状态计算：（当前状态与前面状态的关系）
            对于a[i],b[j]
            1.a[i]和b[j]不存在：这个毫无疑问是f[i-1][j-1]
            2.a[i]不存在，b[j]存在：
                f[i-1][(j?)]，a[i]不存在毫无疑问，但是b[j]存在就比较难确定
                    解释：我们看看当前的状态计算的所有情况，我们会对这些情况取个max
                          也就说会这个max包含b[j]存在与不存在的情况，
                          意思是说我们这个算的其实是max({a[i]不存在b[j]不存在},{a[i]不存在b[j]存在})
                          我们max的项是可以重复
                所有可以确定是f[i-1][j]
            3.a[i]存在,b[j]不存在
                f[i][j-1]
                同2:上式求的是：max({a[i]不存在b[i]存在},{a[i]不存在b[i]存在})
            4.a[i]和b[j]同时存在：
                f[i-1][j-1]+1
            根据推理过程会发现第1类其实是可以忽略掉的，然后取其他的max
*/
#include<bits/stdc++.h>
using namespace std;
int f[1010][1010];
int main(){
    int n,m;
    cin>>n>>m;
    string a,b;
    cin>>a>>b;
    a='0'+a;//注意a[0]
    b='0'+b;
    // cout<<a<<"  "<<b<<endl;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i][j]=max(f[i-1][j],f[i][j-1]);
            // cout<<f[i][j]<<"  ";
            if(a[i]==b[j]){
                f[i][j]=max(f[i][j],f[i-1][j-1]+1);
            }
            // cout<<f[i][j]<<"  ;";
        }
        // cout<<endl;
    }
    cout<<f[n][m];
    return 0;
}
```
## 最短编辑距离
```
给定两个字符串 A 和 B，现在要将 A 经过若干操作变为 B，可进行的操作有：
    删除–将字符串 A 中的某个字符删除。
    插入–在字符串 A 的某个位置插入某个字符。
    替换–将字符串 A 中的某个字符替换为另一个字符。
现在请你求出，将 A 变为 B 至少需要进行多少次操作。
```
![最短编辑距离.jpg](https://cdn.acwing.com/media/article/image/2023/08/08/246003_6860812d35-最短编辑距离.jpg) 
```c++
/*
状态表示f[i,j]:
    1.集合：所有将a[1~i]变成b[1~j]的操作方式
    2.属性：min(这个需要特别注意一下初始化问题)
状态计算：（最后一个状态，为了能更好的控制变量，我们所有的操作都是对最后一个数操作）
    a[1~i-1] + a[i]    (只对a这个进行操作)
    b[1~j-1] + b[j]
    (当前状态，由于前面已经进行过操做，可以认为前面部分是相等的)
    (现在主要是对a[i]的操作)
    （1）a[i]!=b[j]
        1.删a[i]:也就是将a[1~i-1]变为b[1~j]
            f[i-1,j]+1
        2.插入（变为在a[i]后面增）：发现增加b[j]是最好的（为了变得更相似）
            f[i,j-1]+1
        3.替换（将a[i]改为b[j]是最好的）
            f[i-1,j-1]+1
    （2）当且仅当a[i]==b[j]
        f[i-1][j-1]
初始化：大概模拟一下发现：是从（i-1），（j-1）以及（i-1,j-1）方向运算过来的
        也就是要将第一行和第一列初始化：
            f[i,0]：不断删除i次变为b
            f[0,j]: 不断增加j次变为b
*/
#include<bits/stdc++.h>
using namespace std;
int main(){
    int n,m;
    string a,b;//注意这步操作，从a[1]开始
    cin>>n>>a;
    a='0'+a;
    cin>>m>>b;
    b='0'+b;
    
    //初始化
    int f[1010][1010];
    for(int i=0;i<=n;i++){
        f[i][0]=i;
    }
    for(int j=0;j<=m;j++){
        f[0][j]=j;
    }
    
    for(int i=1;i<=n;i++){
        for(int j=1;j<=m;j++){
            f[i][j]=min(f[i-1][j],f[i][j-1])+1;
            if(a[i]==b[j]){
                f[i][j]=min(f[i][j],f[i-1][j-1]);
            }else{
                f[i][j]=min(f[i][j],f[i-1][j-1]+1);
            }
        }
    }
    cout<<f[n][m];
    return 0;
}
```
## 区间合并
 **石头合并**
![石头合并.jpg](https://cdn.acwing.com/media/article/image/2023/08/09/246003_5edb0dca36-石头合并.jpg) 

```
题：
合并 N 堆石子，每次只能合并相邻的两堆石子，求最小代价
```
```
大的区间都是由小区间合并而来
1.究竟能不能贪心？
    你就在放多个贪心策略相同的，看对结果是否有影响
    1 2 1 2 任意合并看看
2.记住这个循环循序：长度->左端点->中间点
3.区间算法要能想起来
```
```c++
//感觉还有点没理解
/*
dp：由一个个小问题去推大问题

区间dp：合并小区间，形成更大区间，知道解决最后区间

（dp分析和细节看图）
算法复杂度:o(n^3)（这里就不写优化的）

区间dp一般递推循环顺序：
    先长度->后左端点->最后中间过渡点
    （初始话后），长度一般从2开始（也可一边初始一边处理）
*/
#include<bits/stdc++.h>
using namespace std;
const int N=3e2+10;
int f[N][N];//最多也就1000*300是不会爆的
int sum[N];//求前缀和，方便合并
int main(){
    int n;
    cin>>n;
    for(int i=1;i<=n;i++){
        //前缀和经典模板
        cin>>sum[i];
        sum[i]+=sum[i-1];
    }
    //区间dp   [l,r]
    for(int len=2;len<=n;len++){
        for(int i=1;i+len-1<=n;i++){
            //细节:保证右端点小于等于n
            //左端点为1，长度为2时，此时右端点为1+2-1
            int l=i,r=i+len-1;
            f[l][r]=1e9;//因为找最小值，初始最大化
            for(int k=i;k<r;k++){//合并界点
                //当k=j-1，此时有区间就已经是[k+1(j),j]
                f[l][r]=min(f[l][r],f[l][k]+f[k+1][r]+sum[r]-sum[l-1]);
            }
        }
    }
    cout<<f[1][n];//将1~n合并
    return 0;
}
```
----------
## 计数类dp
 **整数划分：**
 一个正整数 $n$ 可以表示成若干个正整数之和，形如：$n = n_1 + n_2 + … + n_k$，其中 $n_1 \ge n_2 \ge … \ge n_k, k \ge 1$。
我们将这样的一种表示称为正整数 $n$ 的一种划分。
问 $n$ 一共有多少种划分？


----------


![计数类dp.jpg](https://cdn.acwing.com/media/article/image/2023/08/23/246003_f96246bd41-计数类dp.jpg) 
![计数类dp2.jpg](https://cdn.acwing.com/media/article/image/2023/08/23/246003_fe18806041-计数类dp2.jpg) 

 **法1(自己想的，比较慢)(可跳过)** 
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;
const int N=1e3+10,mod=1e9+7;
int f[N][N];
ll ans;
int main(){
    int n;
    cin>>n;
    //初始化
    for(int i=1;i<=n;i++){
        f[i][i]=1;
    }
    //dp
    for(int i=2;i<=n;i++){
        for(int j=1;j<i;j++){
            for(int k=1;k<=min(i-j,j);k++){
                f[i][j]+=f[i-j][k];
                f[i][j]%=mod;
            }
        }
    }
    for(int i=1;i<=n;i++){
        ans+=f[n][i];
        ans%=mod;
    }
    cout<<ans;
    return 0;
}
```
**法2（转为类似完全背包的形式）**
```c++
/*
f[i,j]这个集合表示，从1~i这几个数中选，总和（总体积）恰为j的数
可以优化成f[j]
*/
#include<bits/stdc++.h>
using namespace std;
int f[1010];
const int mod=1e9+7;
int main(){
    int n;
    cin>>n;
    f[0]=1;
    for(int i=1;i<=n;i++){
        for(int j=i;j<=n;j++){
            f[j]+=f[j-i];
            f[j]%=mod;
        }
    }
    cout<<f[n];
    return 0;
}
```
**法3**


```c++
/*
f[i,j]这个集合表示:总和为i，恰为j个数的和的方案
这里的难点在于如何保证不重不漏
所以这里的划分方式会比较难想：
用最小值为1或大于1来划分（具体看图）
*/
#include<bits/stdc++.h>
using namespace std;
int f[1010][1010];
const int mod=1e9+7;
int main(){
    int n;
    cin>>n;
    f[0][0]=1;
    for(int i=1;i<=n;i++){
        for(int j=1;j<=i;j++){
            f[i][j]=f[i-1][j-1]+f[i-j][j];
            f[i][j]%=mod;
            //一个保证最小值为1，就填个1
            //另一个最小值大于1，就全加1
        }
    }
    long long ans=0;
    for(int i=1;i<=n;i++){
        ans+=f[n][i];
        ans%=mod;
    }
    cout<<ans;
    return 0;
}
```
## 计数问题
```
题：给定两个整数 a 和 b，求 a 和 b 之间的所有数字中 0∼9 的出现次数。
```
**将问题分解不断分解成，好解决的小问题**
![计数问题.jpg](https://cdn.acwing.com/media/article/image/2023/08/09/246003_aaccb82636-计数问题.jpg) 
```c++
/*
本题的难点：
将大问题转为小问题（通过不断的分类讨论）
问题为求a~b中某个数的出现个数：
    对于a~b出现的个数：
        直接转化为类似前缀和的思想，(1~b)-(1~a-1)
        这样可以减少分类的情况
    接下来在分解问题：
    变为每个位置上这个数的出现个数：
    （始终都要注意前导0）
        这里的分析过程就看图吧
        
这就不采用分解数位（y总的），采用是取余和除法来获取前后缀
*/
#include<bits/stdc++.h>
using namespace std;
int len(int x){//用来记录数位的长度
    int l=0;
    while(x){
        l++;
        x/=10;
    }
    return  l;
}
int cnt(int n,int x){//用来统计1~n中x总共的出现次数
    if(n<=0){
        return 0;
    }
    int l=len(n);
    int ans=0;
    //强调一下:这里是讨论x在第i位上的各种情况
    //(为0的就省略掉了)
    for(int i=0;i<l-!x;i++){
    //注意看!x，当x=0时且为最高位时，不成立，所以自动-1
        //统计每一个数位上x的出现次数
        //例如:1~abcde,其中e表示第0位
        int tmp=pow(10,i);
        int l=n/tmp/10,r=n%tmp;//分别表示前后缀
        int nj=n/tmp%10;//表示当前这个数位的值
        //1.当前缀1~l-1
        if(x){//当x不为0
            //前缀0~l-1，中间固定为x，这时后缀0~tmp(排列组合)
            ans+=l*tmp;
        }else{//当x为0
            //这时前缀不能从0开始了，否则后出现【0 0 后缀】
            //应该从1开始【1 0 后缀】
            ans+=(l-1)*tmp;
        }
        //2.当前缀为l时
        if(x==nj){
            ans+=r+1;
        }else if(x<nj){
            ans+=tmp;
        }
        // cout<<ans<<endl;
    }
    return ans;
}
int main(){
    int a,b;
    while(cin>>a>>b&&(a||b)){
        if(a>b){//保证a是小的
            swap(a,b);
        }
        for(int i=0;i<10;i++){
            cout<<cnt(b,i)-cnt(a-1,i)<<' ';
        }
        puts("");
    }
    return 0;
}
```
## 状态压缩dp
### 蒙德里安的梦想
```
求把 N×M 的棋盘分割成若干个 1×2 的长方形，有多少种方案（1≤N,M≤11）
例如当 N=2，M=4 时，共有 5 种方案。当 N=2，M=3 时，共有 3 种方案。
如下图所示：
```
 ![](https://www.acwing.com/media/article/image/2019/01/26/19_4dd1644c20-2411_1.jpg)


----------
![蒙德里安的梦想1.jpg](https://cdn.acwing.com/media/article/image/2023/08/10/246003_31a96c4837-蒙德里安的梦想1.jpg) 
![蒙德里安的梦想2.jpg](https://cdn.acwing.com/media/article/image/2023/08/10/246003_348b953d37-蒙德里安的梦想2.jpg) 

```c++
/*
原理还是要看笔记,这里是对代码的补充
最重要的核心：先放横的，在放竖的
    横的放完，竖的已经固定住了，只能放那几个地方
*/
#include<bits/stdc++.h>
using namespace std;
typedef long long ll;//答案很大
const int N=13,M=1<<13;//N列数，M对应当前列的状态
                    //这里不敢开太多
int n,m;
bool st[M];//判断当前列能否放下竖的
           //方法：所有连续的0需要有偶数个
//预处理j能状态转移的情况，否则要枚举2^n-1
vector<int> state[M];//j->k，但是k可能有多个,所以用二维数组来存
        //第i列的状态为j,但要看i-1 1.能否变为状态j 2.放下竖的
ll f[N][M];//存下dp结果,会爆
int main(){
    
    while((cin>>n>>m)&&(n|m)){
    //&&可以换成','，结合性是右往左，返回最后式子的放回值
    //预处理
      //1.当前列能否放得下竖的
        for(int i=0;i<(1<<n);i++){
        //当前列的每一行，前面一列都可以放横着(放或不放)
        //有n行，对应这2^n-1状态，n个数位
            int cnt=0;//记录连续的0的个数
            bool flag=1;//能放得下
            for(int j=0;j<n;j++){//看每一个数位
                if(i>>j & 1){//当前位为1
                    if(cnt&1){//为奇数
                        flag=0;
                        break;
                    }
                    cnt=0;//这一段合法，开始要看下一段
                }else cnt++;
            }
            if(cnt&1) flag=0;
                //注意：结尾的那一段连续0,这里还要判断
            st[i]=flag;
        }
      //2.当前列的状态i，所能对应的上一列的状态j
            /*
            f[i][j]，当前列i的状态是j,现在要找的i-1列的状态
                要求：（理解牢记状态表示的东西）
                1.当i列这个数位是1，说明在i-1列放了个横的
                  那么【i-2对i-1列的延伸】在这个数位上就不能放横的
                        （就是i-1的状态k）
                  就是说两个数位不能同时存在1(&)
                2.根据状态表示需要将1~i-1摆好：
                    也就是说放好i列需要的横的后：
                        i-1列的状态还要能用竖的填充
                  若i列需要的1，则要将i-1的状态变为1(|)
            */
        for(int i=0;i< 1<<n;i++){
            state[i].clear();//这里state是全局变量
                //上一个n*m到这个不一定成立，所以要清空
            for(int j=0;j< 1<<n;j++){
                if((i&j)==0&&st[i|j])
                    state[i].push_back(j);
                    //这里就是上面的两个要求:
                            //1.放得了横的2.放后能填满i-1列
            }
        }
    //dp
        //初始化
        memset(f,0,sizeof f);
        f[0][0]=1;//第-1列延伸到第0列状态为0的方案数
            //-1列并不存在，不会延伸出任何一个状态，只有一种全为0的
        for(int i=1;i<=m;i++){
            for(int j=0;j< 1<<n;j++){
                //第i列状态为j，并填好i-1列
                for(auto k:state[j]){//遍历j所有对应的k
                    f[i][j]+=f[i-1][k];
                }
            }
        }
        cout<<f[m][0]<<endl;//填好第m-1列（刚好m列），并且没有任何延伸
    }
    return 0;
}
```
### 最短Hamilton路径
```
一张 n 个点的带权无向图，点从 0∼n−1 标号，
求起点 0 到终点 n−1 的最短 Hamilton 路径。
Hamilton 路径的定义：是从 0 到 n−1 不重不漏地经过每个点恰好一次。
（与最短路区分，起0终n-1，每个点都只走过一次，没啥好方法，一般就是需要暴力点）
```
```
可以在看看这个题解:
https://www.acwing.com/solution/content/18533/
```
![最短hamiton路径1.jpg](https://cdn.acwing.com/media/article/image/2023/08/11/246003_f3ce8b4937-最短hamiton路径1.jpg)
![最短hamiton路径2.jpg](https://cdn.acwing.com/media/article/image/2023/08/11/246003_f92d810e37-最短hamiton路径2.jpg) 
```c++
/*
哎呀呀，感觉各种细节及其顺序听得不是很懂
还需要自己再做一下

原理还是看笔记吧,优化直接看下面就行
这里就我自己的感觉像，非常高级的剪枝
就是说一条路径：包含的某几个点，若确定起点终点
        那这个路径的最优路径就可以确定，其他的路就可以全部剪掉
*/
#include<bits/stdc++.h>
using namespace std;
const int N=21,M=1<<N;//64MB能开1.6e7个int
int n;
int w[N][N];//存边权
int f[M][N];//dp结果,初始较大化
void init(){
    memset(f,100,sizeof f);
    f[1][0]=0;//开始从0开始,走过一个0
}
int main(){
    cin>>n;
    init();
    for(int i=0;i<n;i++)//从0开始
        for(int j=0;j<n;j++)
            cin>>w[i][j];
       
    //特别说明一下f[i][j]是我们要得到的最终形态
    //最后的终点要为j，上一个状态终点为k（不能有j这个点）
        //最后一条边k->j
        //有0这个点才会被走，有是这样一个一个加，不会出现前面的集合漏更新的情况
        //这里顺序是乱的，可能走完后面的几个点在走前面的
    for(int i=1;i< 1<<n;i+=2)
        /*i=0,i++：所有可能走过的点的集合
          优化：i=1,i+=2，保证从0点开始
          下面的终点也能写为1*/
        for(int j=0;j<n;j++)//所有可能的终点，应该可以从1开始
            if(i>>j &1)//需要保证走过点的集合中有终点
                for(int k=0;k<n;k++)//从k这个终点->j这个终点
                    if(i>>k & 1)
                        /*一开始的判断条件是：(i-(1<<j))>>k & 1
                            这里判断的是上一个状态点集合一定要有终点k
                          优化：当k==j时,f[i-(1<<j)][j]+w[j][j]
                            没有j这个点，最后一个点不可能为j,所以一定不存在*/
                        f[i][j]=min(f[i][j],f[i-(1<<j)][k]+w[k][j]);
    
    
    cout<<f[(1<<n)-1][n-1];//所有点都走过，终点为n-1
    //一定要注意<<优先级很低
    return 0;
}
```
## 树形DP
### **没有上司的舞会**

```
有n名职员，从1~n标号，每名职员的都有相应的高兴值H[i]
他们的关系是以校长为根的树，父节点就是直接的上司
现在要开一场宴会，要求没有直接上司，使所有参会职员的快乐总数最大
```
![没有上司的舞会.jpg](https://cdn.acwing.com/media/article/image/2023/08/13/246003_6aa3e62539-没有上司的舞会.jpg) 
```c++
时间复杂度O(n)
#include<bits/stdc++.h>
using namespace std;
const int N=6010;
int n,happy[N];
//树用邻接表存
    //只需存一条边从根节点一直遍历下来就行
int h[N],e[N],ne[N],idx;
//起点x最新出现的位置，终点y，以i同起点的上一条边
void init(){
    memset(h,-1,sizeof h);
}
void add(int x,int y){//指向上一个同起点的出现的方向
    e[idx]=y,ne[idx]=h[x],h[x]=idx++;
}
bool has_fa[N];
int f[N][2];//树型dp
void dfs(int u){//遍历x这个子树
    f[u][1]=happy[u];//记住还有本身的高兴值
    for(int i=h[u];~i;i=ne[i]){
    //~i等价于i!=-1,负数是用反码+1存的，所-1二进制表示全是1
        int s=e[i];
        dfs(s);
        f[u][0]+=max(f[s][0],f[s][1]);//没选u，儿子可选可不选
        f[u][1]+=f[s][0];//选上了u,儿子就不能选
    }
}
int main(){
    cin>>n;
    init();//哎呀呀，还有一件事:别忘记初始化
    for(int i=1;i<=n;i++) cin>>happy[i];
    for(int i=1;i<n;i++){
        int x,y;//y是x的上司，在上面
        cin>>x>>y;
        add(y,x);
        has_fa[x]=1;
    }
    int root=1;//从1开始寻找根节点
    while(has_fa[root]) root++;
        //根节点的特征无爸爸
    dfs(root);
    cout<<max(f[root][0],f[root][1]);
    return 0;
}
```
### [E-小红的树上赋值方案_第6届传智杯复赛第一场（补题）](https://ac.nowcoder.com/acm/contest/72647/E)

题目：

小红拿到了一棵有根树，其中有一些节点被染成了红色。树的根节点是 1 号节点。
小红希望你给每个节点的权值赋值为 1 或者 2，需要满足每个红色节点的子树节点权值之和为 3 的倍数。
请你帮小红求出赋值的合法方案数。由于答案可能过大，请对$10^9+7$取模。

![传智杯树形dp.jpg](https://cdn.acwing.com/media/article/image/2024/01/30/246003_2ada0b20bf-传智杯树形dp.jpg) 

```java
import java.util.*;
import java.io.*;
public class Main{
    static final int N=(int)1e5+10;
    static String co=" ";//颜色，从1开始
    static int mod=(int)1e9+7;
    //邻接表（存图，只要存向下的方向就行）
    static int[] e=new int[N],ne=new int[N],h=new int[N];
    static int idx;
        //e存的是当前边终点
        //ne存的当前边是上一次以x为起点的边的下标
        //h存的是以x为起点最新的一条边
    static void init(){
        Arrays.fill(h,-1);//开始没有以x为起点的边
    }
    static void add(int x,int y){
        e[idx]=y;
        ne[idx]=h[x];
        h[x]=idx++;
    }
    
    //树状dp（具体分析看笔记）
    static long[][] f=new long[N][3];//由于涉及乘法，相当容易爆int
    static void dfs(int u){
        //初始化
        f[u][1]=f[u][2]=1;//只有这个结点时，能选1或者2
        for(int i=h[u];i!=-1;i=ne[i]){
            long[] b={f[u][0],f[u][1],f[u][2]};//备份数组
            f[u][0]=f[u][1]=f[u][2]=0;//记得清0
                //值传底，不是引用
            int k=e[i];//儿子k
            dfs(k);
            for(int x=0;x<3;++x){
                for(int y=0;y<3;++y){
                    int j=(x+y)%3;
                    f[u][j]+=(b[x]*f[k][y])%mod;
                    f[u][j]%=mod;//后面又加了
                    if(co.charAt(k)=='R') break;//当为红色结点y只能等于0
                }
            }
        }
    }
    public static void main(String[] args){
        init();//千万别忘记初始化
        
        Scanner sc=new Scanner(System.in);
        int n=sc.nextInt();
        co+=sc.next();
        for(int i=2;i<=n;++i){
            int t=sc.nextInt();//结点的父亲
            add(t,i);
        }
        dfs(1);
        long ans=0;
        if(co.charAt(1)=='R') ans=f[1][0];
        else{
            for(int i=0;i<3;++i)
                ans=(ans+f[1][i])%mod;
        }
        System.out.println(ans);
//         for(int i=1;i<=3;++i){
//             for(int j=0;j<3;++j){
//                 System.out.print(f[i][j]+" ");
//             }System.out.println();
//         }
    }
}
```



## 记忆化搜索

**滑雪**
![记忆化搜索.jpg](https://cdn.acwing.com/media/article/image/2023/08/13/246003_cdfdc6f439-记忆化搜索.jpg) 
```
给定一个n行m列的矩阵，给定（i，j）的高度
可以从任意一点出发，每次可以滑向相邻的（上下左右）高度低的
求出最多可与经过几个点
```
```c++
有个非常重要的条件：不能走之前走过的路
        （这个路径图必须是有向无环）
每个点只搜一次，所以时间复杂度应该是O(所有点)
#include<bits/stdc++.h>
using namespace std;
const int N=310;
int n,m,g[N][N];//存高度
int f[N][N];//记忆化，避免重复搜
int mx[4]={-1,1,0,0};//上下左右移动
int my[4]={0,0,-1,1};
int dp(int x,int y){//尽量别设为i,j
    int &v=f[x][y];//引用符，取个别名
    if(v) return v;
    v=1;//没走过，就将他设为起点
    for(int i=0;i<4;i++){
        int tx=x+mx[i],ty=y+my[i];
        if(tx<1||tx>n||ty<1||ty>m||g[x][y]<=g[tx][ty])
            continue;//不合法和不能走的情况
        v=max(v,dp(tx,ty)+1);//每走一步就加1
    }
    return v;
}
int main(){
    cin>>n>>m;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            cin>>g[i][j];
    int ans=0;
    for(int i=1;i<=n;i++)
        for(int j=1;j<=m;j++)
            ans=max(ans,dp(i,j));
    cout<<ans;
    return 0;
}
```
# 贪心

通过局部最优解获得整体最优解（只关注眼前，很短视）

[均等假设法：](https://cloud.tencent.com/developer/article/2083415)

​		同一个局面，如果这个贪心策略最后会产生两种不同的结果，那么不能用贪心

## 区间问题

### 区间选点

```
给定 N 个闭区间 [ai,bi]，请你在数轴上选择尽量少的点，
使得每个区间内至少包含一个选出的点。输出选择的点的最小数量。
位于区间端点上的点也算作区间内。
```
![区间选点.jpg](https://cdn.acwing.com/media/article/image/2023/08/15/246003_5d038ea23b-区间选点.jpg) 
```c++
时间复杂度O(n)
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int n;
struct Range{
    int l,r;
    bool operator<(const Range &other)const{
        return r<other.r;//按右端点从小到大排序
    }
}a[N];
int main(){
    cin>>n;
    for(int i=0;i<n;i++) scanf("%d%d",&a[i].l,&a[i].r);
    sort(a,a+n);
    int ans=0,ed=-1e9-10;//ed是右界
    for(int i=0;i<n;i++){
        if(a[i].l>ed){
            ans++;
            ed=a[i].r;
        }
    }
    cout<<ans;
    return 0;
}
```
### 最大不相交区间数量
```
给定 N 个闭区间 [ai,bi]，使得选中的区间之间互不相交（包括端点）。
输出可选取区间的最大数量。
```
![最大不相交区间数量.jpg](https://cdn.acwing.com/media/article/image/2023/08/15/246003_d0b01db83b-最大不相交区间数量.jpg) 
数轴从左往右看，每次都给数轴留尽可能多的区间
```c++
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
struct Range{
    int l,r;
    bool operator<(const Range &other)const{
        return r<other.r;//const不能改变原值
    }//等于的情况不影响
}a[N];
int main(){
    int n;cin>>n;
    for(int i=0;i<n;i++) scanf("%d%d",&a[i].l,&a[i].r);
    sort(a,a+n);
    int ans=0,ed=-2e9;
    for(int i=0;i<n;i++){
        if(a[i].l>ed){
            ans++;
            ed=a[i].r;
        }
    }
    cout<<ans;
    return 0;
}
```
### 区间分组
```
给定 N 个闭区间 [ai,bi]，
请你将这些区间分成若干组，使得每组内部的区间两两之间（包括端点）没有交集，
并使得组数尽可能小。输出最小组数。
```
```
可以多去看看题解和评论，有一些很巧妙的思维
```
**贪心**

> 那个步骤有个错了，以代码为主

![区间分组1.jpg](https://cdn.acwing.com/media/article/image/2023/08/16/246003_48f2307b3c-区间分组1.jpg)

 

```c++
/*
唉，想不到这题是真给我难住了，思路非常混乱
看来贪心真不简单啊，尤其是如何像策略和证明
但这题感觉又不太像贪心，
    更像是分类讨论后的模拟
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
struct Range{
    int l,r;
    bool operator<(const Range &other)const{
        return l<other.l;//l小的排前面
    }
}a[N];
int main(){
    int n;cin>>n;
    for(int i=0;i<n;i++) scanf("%d%d",&a[i].l,&a[i].r);
    sort(a,a+n);
    priority_queue<int,vector<int>,greater<int> > h;
    //存组，存的是右端点
        //堆，小的优先
    for(int i=0;i<n;i++){
        if(h.empty()||h.top()>=a[i].l){
        //连最右一组都有交集，放不了，再开一组
            h.push(a[i].r);
        }else{//这里可以放在任一个符合条件的地方
            h.pop();//为了方便放在了，第一个
            h.push(a[i].r);
        }
    }
    cout<<h.size();
    return 0;
}
```
**差分+离散化**
![区间分组2.jpg](https://cdn.acwing.com/media/article/image/2023/08/16/246003_0f302b123c-区间分组2.jpg) 
这有这个元素怎么返回都是元素的指针
```c++
/*
所有组的两两区间内部不能有交集，要求的是最小组数
转化下问题：
    看成安排活动，区间就是每个活动的开始和结束时间
    同一个教室不能安排时间有冲突的活动,
    需要排所有的活动，问最少需要几间教室
只需要求峰值的需要的教室数
(这里感觉思维跨度是很大的，有点没想明白，具体还是看笔记吧)

于是问题就变成了，区间修改=>差分
    由于这个区间范围很大，是要用离散化求回区间和
    但是由于只涉及求峰值，所以可以用精简版（也可以用map）
    （但map会有点慢）
    (涉及到区间查询上面两种就不好用了)
*/
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
typedef pair<int,int> pii;
vector<pii> alls;//离散化后数轴（存下原来的位置和差分）
#define x first//原来的x
#define c second//差分值
int main(){
    int n;cin>>n;
    for(int i=0;i<n;i++){
        int l,r;scanf("%d%d",&l,&r);
        alls.push_back({l,1});
        alls.push_back({r+1,-1});
        //pair的second那个部分进行区间修改
    }
    sort(alls.begin(),alls.end());//用原来的位置进行排序
    int k=0,ans=0;//记录变化，找峰值
    for(int i=0;i<alls.size();i++){//离散化后的数轴
        k+=alls[i].c;
        ans=max(ans,k);
            /*这里是需要注意的点：
                正常应该是需要整个时间点算完，在判断的
                比如x=50,c[50]=(1,1,-1,-1),万一1先算了，会使结果偏大
                (50处的值=sum[49]+c[50],如果先加1，显然结果会偏大)
                但是这里是同x，c小的排前面，所以没事
            */  
    }
    cout<<ans;
    return 0;
}
```
### 区间覆盖

> 这里有点区间合并的感觉，可以去第一章看看区间合并

```
给定 N 个闭区间 [ai,bi] 以及一个线段区间 [s,t]，
请你选择尽量少的区间，将指定线段区间完全覆盖。
输出最少区间数，如果无法完全覆盖则输出 −1。
```
> **特殊的情况：**
>
> 注意是不是点，只要点相邻就能合并
>
> 比如[1,1]和[2,2]能合并
>
> 特别容易写出bug:
>
> 下面的模板j移动那边判断变为`while(j<n&&a[j].l<=st+1)`，可恶要还要**注意是否有起点**，**如果刚好`右界+1==起点`,这样其实是没有连起来的**【如果题目这样改，会有这样的特性】
>
> **特此警示，这里要千万注意，左端点大的，右端点不一定大[1,100],[2,50]，不要有任何特判右端点的行为**



> **除非问区间数，且数很大的，用离散化麻烦时，否则尽量别用这个模板，会有很多边界问题**

> 如果只是**问能否覆盖一个区间**，建议用这个
>
> **需要注意就是这个区间必须是==实际的==**【如果超过边界记得剪】
>
> ```c++
> 		//纯纯的区间合并
> 		long st=-1,ed=-1;
> 		for(int i=0;i<cnt;++i) {
> 			if(sg[i].l<=ed+1) ed=Math.max(sg[i].r,ed);
> 			else {//没连起来
> 				st=sg[i].l;
> 				ed=sg[i].r;
> 			}
> 		}
> 		return st==1&&ed==len;
> ```
>
> 

![区间覆盖.jpg](https://cdn.acwing.com/media/article/image/2023/08/17/246003_a42be5783c-区间覆盖.jpg)  

```c++
//用y总的双指针算法比较好
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
struct Range{
    int l,r;
    bool operator<(const Range &other)const{
        return l<other.l;//左端点排序
    }
}a[N];
int main(){
    int st,ed;//start,end
    cin>>st>>ed;
    int n;cin>>n;
    for(int i=0;i<n;i++) cin>>a[i].l>>a[i].r;
    sort(a,a+n);
    /*从前往后枚举：
        在所有可能包含st的区间，找出右端点最大的区间，
        若找到则更新st
        
      这个st就是覆盖区间的右端点，
        需要覆盖的左端点就是初始值
    */
    int ans=0;
    bool flag=0;//看是否找到答案
    for(int i=0,j=0;i<n;){//双指针算法
        int  tr=-1e9;//暂时的右端点
        while(j<n&&a[j].l<=st){//是否被包含
            tr=max(a[j].r,tr);
            j++;//注意这里j最终会使a[j].l>st
        }
        if(tr<st) break;//出现了断层，与后面的区间连不起来了
            /*注意这里不取等号，
                这里有一种特殊情况，就是最开始的右端点到st就能结束了
                比如要覆盖[1,1]，区间是[1,1]*/
        //区间合并
        ans++;
        st=tr;
        if(st>=ed){
            flag=1;
            break;
        }
        i=j;
    }
    if(flag) cout<<ans;
    else     cout<<-1;
    return 0;
}
```
> 就算`tr==st`也没事，因为双指针j已经走出去了，下一个会自动结束循环

## 合并果子

```
按果子的不同种类分成了不同的堆,达达决定把所有的果子合成一堆。
每一次合并，达达可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。
达达在合并果子时总共消耗的体力等于每次合并所耗体力之和。
```
![合并果子.jpg](https://cdn.acwing.com/media/article/image/2023/08/17/246003_d5bf2c643c-合并果子.jpg) 
```c++
#include<bits/stdc++.h>
using namespace std;
priority_queue<int,vector<int>,greater<int> > h;
//小根堆，小的优先
int main(){
    int n;cin>>n;
    for(int i=0;i<n;i++){
        int a;cin>>a;
        h.push(a);
    }
    int ans=0;//不会爆ll
    while(h.size()>1){
        int a=h.top();h.pop();
        int b=h.top();h.pop();
        ans+=a+b;
        h.push(a+b);
    }
    cout<<ans;
    return 0;
}
```
#### 时间复杂度：（来自y总）



> 使用小根堆维护所有果子，每次弹出堆顶的两堆果子，并将其合并，合并之后将两堆重量之和再次插入小根堆中。



> 每次操作会将果子的堆数减一，一共操作 $n - 1$ 次即可将所有果子合并成1堆。每次操作涉及到2次堆的删除操作和1次堆的插入操作，计算量是 $O(logn)$。因此总时间复杂度是 $O(nlogn)$。
>
## 排序不等式
**排队打水**
```
有 n 个人排队到 1 个水龙头处打水，第 i 个人装满水桶所需的时间是 ti，
请问如何安排他们的打水顺序才能使所有人的等待时间之和最小？
```
![排队打水.jpg](https://cdn.acwing.com/media/article/image/2023/08/17/246003_f30389be3c-排队打水.jpg) 
```c++
#include<bits/stdc++.h>
using namespace std;
typedef long long  ll;//会爆int
const int N=1e5+10;
int  t[N];
int main(){
    int n;cin>>n;
    for(int i=1;i<=n;i++) cin>>t[i];
    sort(t+1,t+1+n);//从小到大排，注意要+1
    ll ans=0;
    for(int i=1;i<=n;i++){
        ans+=(n-i)*t[i];
    }
    cout<<ans;
    return 0;
}
```
## 绝对值不等式
### **货仓选址**

```
在一条数轴上有 N 家商店，它们的坐标分别为 A1∼AN。
现在需要在数轴上建立一家货仓，每天清晨，从货仓到每家商店都要运送一车商品。
为了提高效率，求把货仓建在何处，可以使得货仓到每家商店的距离之和最小。
```
![绝对值不等式1.jpg](https://cdn.acwing.com/media/article/image/2023/08/18/246003_560c56d13d-绝对值不等式1.jpg) 

---

### **==糖果传递:==**(均分纸牌问题)

有 $n$ 个小朋友坐成一圈，每人有 $a[i]$ 个糖果。
每人只能给左右两人传递糖果。
每人每次传递一个糖果代价为 $1$。
求使所有人获得均等糖果的最小代价。

![绝对值不等式2.jpg](https://cdn.acwing.com/media/article/image/2023/08/18/246003_5a38a11a3d-绝对值不等式2.jpg)

>  假设只需要相邻的只需要一次性传递完该传的就行了，就是不会出现又还回去一些糖果(冗余啦)
>
> 可正可负，表示的是方向

```c++
//抽象：求一个点与所有的距离和最小
//暴力会超时
//可恶，模拟半天，没找到什么好方法

/*
最后需要数学:绝对值不等式
对于两个数：
|a1-x|+|a2-x|>=|a1-a2|
(画画图就懂了)
（注意：x要取在中间，且边界a1,a2是能取到的）
多个数就大值与小值为1组
最好要在所有组的中间段，发现中位数恰好符合

取中位数：法1：sort                     （O(nlogn)）
          法2：nth_element()  （快一点）(O(n))
*/
#include<bits/stdc++.h>
using namespace std;
const int maxn=1e5+10;
int a[maxn];
int main(){
    int n;
    cin>>n;
    for(int i=0;i<n;i++){
        cin>>a[i];
    }
    // sort(a,a+n);
    int k=n>>1;
    nth_element(a,a+k,a+n);
    int ans=0;//4e3*5e4刚好不会爆
    for(int i=0;i<n;i++){
        ans+=fabs(a[i]-a[k]);
    }
    cout<<ans;
    return 0;
}
```
## 推公式

**耍杂技的牛**
```
有n个牛，每头都有相应的重量w[i]和强壮程度s[i]。
现在要叠罗汉，
一头牛支撑不住的风险值等于：
    它头上所有牛的总重量（不包括它自己）减去它的身体强壮程度的值，
风险值越大，这只牛撑不住的可能性越高。
您的任务是确定奶牛的排序，使得所有奶牛的风险值中的最大值尽可能的小。
```

![推公式.jpg](https://cdn.acwing.com/media/article/image/2023/08/18/246003_8af65f393d-推公式.jpg) 
```c++
//失败了，完全没想出来
/*以后可以试下这个思路：
    如果从总体所有的公式入手，毫无头绪
    1.若跟顺序无关，可以随便设两个（绝对值不等式）
    2.否则，可以试下i位置上相邻的两个，
        试着交换一下位置
        看看能否更优
    记住：1.尽量将相关的放一起
          2.分类讨论，更方便
*/
#include<iostream>
#include<algorithm>
#include<climits>//最值,当然用浮点表示也行
using namespace std;
const int N=5e4+10;
//不会爆ll,5e4*1e4
struct Cow{
    int w,s;
    bool operator<(const Cow &other)const{
    //默认是原来在前，other在后
        //这样就是使得每一个都按这个式子排
            //原来w+s小的在前
        return w+s<other.w+other.s;
        //是每一个都不能交换
    }
}a[N];
int main(){
    int n;cin>>n;
    for(int i=0;i<n;i++)cin>>a[i].w>>a[i].s;
    sort(a,a+n);
    int sum=0,ans=INT_MIN;
            //ans需要较小化，可能为负数
    for(int i=0;i<n;i++){
        ans=max(ans,sum-a[i].s);
        sum+=a[i].w;
    }
    cout<<ans;
    return 0;
}
```





## 每组数都变同值



**画柱状图，在画那值的线**

**一般要配合排序和前缀和来解决**



[leetcode 每日一题 2024年01月18日 拿出最少数目的魔法豆 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/678512111)

题目：有多组每组豆子堆，每次能拿一个豆子，最后要让每一个非空组的的豆子数都变为一样的

​			例如：[4 1 6 5]=>[4,0,4,4]

![](https://pic3.zhimg.com/80/v2-4bee57ae7e699447f41527fd032518fa_1440w.webp)

> 前面还少一些比较低的

**逆向思维**：算留下来的豆子

>  先排序，一个个枚举，前面的高度都是比较a[x]低的都是要拿掉的，比a[x]高的也是要拿掉，剩下的是一个矩形$(剩下的+1)*a[x]$，其他就是拿掉

## 多路归并

[1262. 鱼塘钓鱼 - AcWing题库](https://www.acwing.com/problem/content/description/1264/)

有 $N$ 个鱼塘排成一排，每个鱼塘中有一定数量的鱼，例如：$N=5 $时，如下表：

|                     鱼塘编号                     |  1   |  2   |  3   |  4   |  5   |
| :----------------------------------------------: | :--: | :--: | :--: | :--: | :--: |
|        第1分钟能钓到的鱼的数量（1..1000）        |  10  |  14  |  20  |  16  |  9   |
|        每钓鱼1分钟钓鱼数的减少量（1..100)        |  2   |  4   |  6   |  5   |  3   |
| 当前鱼塘到下一个相邻鱼塘需要的时间（单位：分钟） |  3   |  5   |  4   |  4   |      |

> 这里把分钟把改为次数，会更好理解点
>
> 当前鱼塘到下一个相邻鱼塘（这个理解为无向边）

即：在第 $1$ 个鱼塘中钓鱼第 $1$ 分钟内可钓到 $10$ 条鱼，第 $2$ 分钟内只能钓到 $8$ 条鱼，……，第 $5$ 分钟以后再也钓不到鱼了。
从第 $1$ 个鱼塘到第 $2$ 个鱼塘需要 $3$ 分钟，从第 $2$ 个鱼塘到第 $3$ 个鱼塘需要 $5$ 分钟，……

给出一个截止时间 $T$，设计一个钓鱼方案，从第 $1$ 个鱼塘出发，希望能钓到最多的鱼。
假设能钓到鱼的数量仅和已钓鱼的次数有关，且每次钓鱼的时间都是整数分钟。

**数据范围**:$1 \le N \le 100$,$1 \le T \le 1000$

---

![多路归并.jpg](https://cdn.acwing.com/media/article/image/2024/04/04/246003_6234b64df2-多路归并.jpg) 

```java
//贪心+多路归并合并
	//这里用堆来实现多路的归并合并，但是其实数据量太小了，直接枚举也行，具体看y总的
/**
 * 具体看图吧
 * 1.就是不需要折返（贪心，都是把这个池塘的时间花完在走的，不需要在路上反复耗时间）
 * 	 枚举每一个终点就行了，然后总时长都是T
 * 2.扣去路途剩下的时间，需要对应分配给每个池塘的时间（多路归并，让能钓到的鱼最多），
 * 			每个池塘随着分钟钓到的鱼数是递减的
 */
import java.io.*;
import java.util.*;
class Pair{
	int x,y;
	public Pair(int x, int y) {
		super();
		this.x = x;
		this.y = y;
	}
	
}
public class Main{
	static int N=110;
	static int n,T;//总时长
	static int[] first=new int[N],d=new int[N],l=new int[N];//对应题目的三个数组
			//开始的鱼量，每分钟减多少，到这个鱼池需要花费的时间
			//l为了方便直接前缀和出发了
	/**
	 * 当前终点为k时，最多能钓多少鱼
	 * @param k:终点
	 * @param t:剩下的时间
	 * @return
	 */
	static int work(int k,int t) {
		if(t<=0) return 0;//剩下的时间根本不够
		int res=0;
		Queue<Pair> q=new PriorityQueue<>((a,b)->{
			return b.x-a.x;//后者是小的，降序
		});//这里需要额外记录下编号，方便找下位
		for(int i=1;i<=k;++i)
			q.add(new Pair(first[i],i));
		//多路归并：把剩下的时间分配给对应的池塘
		for(int i=0;i<t&&!q.isEmpty();++i) {//特判是否非空
			Pair tmp=q.remove();
			res+=tmp.x;
			tmp.x-=d[tmp.y];//第i路下一个对应是什么
			if(tmp.x>0) q.add(tmp);//直接把tmp这点弄进去也没事
		}
		return res;
	}
	public static void main(String[] args){
		Scanner sc=new Scanner(System.in);
		n=sc.nextInt();
		for(int i=1;i<=n;++i)
			first[i]=sc.nextInt();
		for(int i=1;i<=n;++i) 
			d[i]=sc.nextInt();
		for(int i=2;i<=n;++i) //注意这里是从2开始的
			l[i]=sc.nextInt()+l[i-1];
		T=sc.nextInt();
		//枚举路径（起点固定，不会折返，只需枚举终点）
		int res=0;
		for(int i=1;i<=n;++i) {
			res=Math.max(res,work(i,T-l[i]));
		}
		System.out.println(res);
	}
}
/**
 * 本题独立解题失败了，一开始连题目都没搞懂
 * 这个每分钟鱼的减少量，感觉用每次在这个池塘鱼的减少量会更准确定点
 * 
 * 一些启发：像这种最好就是把每分钟的矩阵图也画出来，思路会更好想点
 */
```

参考：[看下面的代码](https://www.acwing.com/video/5344/)

### 等差数列多路归并=>二分答案优化

[AcWing 4656. 技能升级（蓝桥杯辅导课） - AcWing](https://www.acwing.com/activity/content/problem/content/9735/)

小蓝最近正在玩一款 $RPG$ 游戏。
他的角色一共有 $N$ 个可以加攻击力的技能。
其中第 $i$ 个技能首次升级可以提升 $A_i$ 点攻击力，以后每次升级增加的点数都会减少 $B_i$。
$\lceil \frac{A_i}{B_i} \rceil$（上取整）次之后，再升级该技能将不会改变攻击力。
现在小蓝可以总计升级 $M$ 次技能，他可以任意选择升级的技能和次数。
请你计算小蓝最多可以提高多少点攻击力？

**数据范围**:对于所有评测用例，$1 ≤ N ≤ 10^5$，$1 ≤ M ≤ 2 × 10^9$，$1 ≤ A_i, B_i ≤ 10^6$。

----



```java
/**
 * 哎呀呀呀，最基本的题目必须要读清楚
 * 这里加技能只会加B[i]，如果小了就是加不了，这个一定搞明白
 * 
 * 这里暴力做法:多路归并
 * 但是时间复杂度为O(mlogm),肯定是过不了的
 * 需要优化一下，不能去跟m相关需要跟n相关
 */
/**
 * 优化：二分答案
 * 	中间过渡一下，我们求第m个数值X为多少
 * 	这里用二分答案来求
 * 		1.确定哪个模板
 * 			当<=X时，能加攻击力的个数>=m个
 * 			当>X时，能加攻击力的个数<m个
 * 			所以这里找的是符合答案的最大值
 * 			如何求每个分路的能加的攻击力个数？
 * 				个数=(int)(A[i]-X)/B[i]+1
 * 		2.画图
 * 		3.注意：最后不一定能刚好取到m个，可能会超过，需要减去超过的	
 * 				最终这个X刚好就是一个边界，也就是说<=X-1会加超过m，
 * 				那么这些多的值都会是m
 * 	最后：当前路的攻击力总和用等差数列求和公式来求
 * 			当前路的攻击力总和=(首相+尾项)*数量/2
 * 
 * 注意：当前路的值如果小于B[i]就是取不了了
 * 
 * 时间复杂度:O(nlogn)
 */
import java.io.*;
import java.util.*;
public class Main{
	static int N=(int)1e5+10;
	static int n,m;
	static int[] A=new int[N],B=new int[N];
	/**
	 * 前提：A[i]要取，即A[i]>=x
	 * 获取当前路i，当第m个值为x时，能加的攻击路个数
	 * @param i
	 * @param x
	 * @return
	 */
	static int getcnt(int i,int x) {
		return (A[i]-x)/B[i]+1;
	}
	static boolean check(int x) {
		long cnt=0;//数量也是会爆的
		for(int i=0;i<n;++i) {
			if(A[i]>=x)
				cnt+=getcnt(i,x);
		}
		if(cnt>=m) 
			return true;
		else
			return false;
	}
	public static void main(String[] args) throws Exception{
		BufferedReader br=new BufferedReader(new InputStreamReader(System.in));
		String[] ss=br.readLine().split(" ");
		n=Integer.parseInt(ss[0]);
		m=Integer.parseInt(ss[1]);
		for(int i=0;i<n;++i) {
			ss=br.readLine().split(" ");
			A[i]=Integer.parseInt(ss[0]);
			B[i]=Integer.parseInt(ss[1]);
		}
		int l=0,r=(int)1e6;//下界：所用的用完不够m
		//找最大值的模板
		while(l<r) {
			int mid=(l+r+1)>>1;
			if(check(mid)) l=mid;
			else		   r=mid-1;//配齐
		}
		//计算当攻击力的总和
		long res=0,cnt=0;
		for(int i=0;i<n;++i) 
			if(A[i]>=l) {
				int c=getcnt(i,l);
				cnt+=c;
				int end=A[i]-B[i]*(c-1);
				res+=(long)(A[i]+end)*c/2;//这个肯定会爆
			}
		//需要减去多加的
		res-=(cnt-m)*l;
		System.out.println(res);
	}
}
```

